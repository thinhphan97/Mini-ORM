{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mini_orm","text":"<p>Lightweight Python ORM-style toolkit.</p>"},{"location":"#what-it-supports","title":"What it supports","text":"<ul> <li>Dataclass-based SQL models.</li> <li>Single-table CRUD via <code>Repository[T]</code>.</li> <li>Multi-model routing with one hub object via <code>UnifiedRepository</code>   (object-only mutation support included).</li> <li>Async SQL flow via <code>AsyncRepository[T]</code>, <code>AsyncUnifiedRepository</code>, and <code>AsyncDatabase</code>.</li> <li>Optional schema auto-sync with <code>auto_schema=True</code> and conflict policy <code>schema_conflict</code>.</li> <li>Optional strict registration with <code>require_registration=True</code> and <code>register(..., ensure=...)</code>.</li> <li>Model relations inferred from FK metadata (<code>fk</code>, <code>relation</code>, <code>related_name</code>) with   nested create and eager-loading (<code>get_related</code>, <code>list_related</code>).</li> <li>Safe query building (<code>where</code>, <code>AND/OR/NOT</code>, <code>order by</code>, <code>limit</code>, <code>offset</code>).</li> <li>Repository utility APIs: <code>count</code>, <code>exists</code>, <code>insert_many</code>, <code>update_where</code>, <code>delete_where</code>, <code>get_or_create</code>.</li> <li>Field codecs for DB I/O:</li> <li>Enum &lt;-&gt; scalar (<code>Enum.value</code>)</li> <li>JSON &lt;-&gt; Python structures (<code>dict</code>/<code>list</code>, or explicit <code>metadata={\"codec\": \"json\"}</code>)</li> <li>Schema generation from model metadata.</li> <li>Index support:</li> <li>Field metadata (<code>index</code>, <code>unique_index</code>, <code>index_name</code>)</li> <li>Multi-column indexes via <code>__indexes__</code></li> <li>One-call schema apply with <code>apply_schema(...)</code></li> <li>Async schema apply with <code>apply_schema_async(...)</code></li> <li>Idempotent mode with <code>if_not_exists=True</code></li> <li>SQL dialect adapters: SQLite, Postgres, MySQL.</li> <li>Vector abstraction via <code>VectorRepository</code> / <code>AsyncVectorRepository</code>:</li> <li><code>InMemoryVectorStore</code> (built-in)</li> <li><code>PgVectorStore</code> (PostgreSQL + pgvector extension)</li> <li><code>QdrantVectorStore</code> (optional, requires <code>qdrant-client</code>)</li> <li><code>ChromaVectorStore</code> (optional, requires <code>chromadb</code>)</li> <li><code>FaissVectorStore</code> (optional, requires <code>faiss-cpu</code> and <code>numpy</code>)</li> <li>Optional payload codec for metadata/filter I/O     (<code>IdentityVectorPayloadCodec</code>, <code>JsonVectorPayloadCodec</code>)</li> </ul>"},{"location":"#quick-usage-sql","title":"Quick usage (SQL)","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Optional\nimport sqlite3\n\nfrom mini_orm import Database, SQLiteDialect, Repository, C, apply_schema\n\n@dataclass\nclass User:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    email: str = field(default=\"\", metadata={\"index\": True})\n\nconn = sqlite3.connect(\":memory:\")\ndb = Database(conn, SQLiteDialect())\nrepo = Repository[User](db, User)\n\napply_schema(db, User)\nrepo.insert(User(email=\"alice@example.com\"))\nrows = repo.list(where=C.eq(\"email\", \"alice@example.com\"))\n\nrows = repo.list(\n    where=C.or_(\n        C.eq(\"email\", \"alice@example.com\"),\n        C.eq(\"email\", \"bob@example.com\"),\n    ),\n    limit=10,\n)\ntotal = repo.count(where=C.like(\"email\", \"%@example.com\"))\n</code></pre>"},{"location":"#quick-usage-async-sql","title":"Quick usage (Async SQL)","text":"<pre><code>import asyncio\nimport sqlite3\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom mini_orm import AsyncDatabase, AsyncRepository, SQLiteDialect\n\n@dataclass\nclass User:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    email: str = field(default=\"\", metadata={\"index\": True})\n\nasync def main() -&gt; None:\n    conn = sqlite3.connect(\":memory:\")\n    db = AsyncDatabase(conn, SQLiteDialect())\n    try:\n        repo = AsyncRepository[User](db, User, auto_schema=True)\n        await repo.insert(User(email=\"alice@example.com\"))\n        rows = await repo.list()\n        print(rows)\n    finally:\n        conn.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"#relations-via-metadata-quick-view","title":"Relations via metadata (quick view)","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Optional\n\n@dataclass\nclass Author:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    name: str = \"\"\n\n@dataclass\nclass Post:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    author_id: Optional[int] = field(\n        default=None,\n        metadata={\n            \"fk\": (Author, \"id\"),\n            \"relation\": \"author\",\n            \"related_name\": \"posts\",\n        },\n    )\n    title: str = \"\"\n</code></pre> <p>Inferred relations: - <code>Post.author</code> (<code>belongs_to</code>) - <code>Author.posts</code> (<code>has_many</code>)</p> <p>Detailed guide: - <code>docs/sql/repository.md</code> section \"Relations (create and query)\"</p>"},{"location":"#quick-usage-vector","title":"Quick usage (Vector)","text":"<pre><code>from mini_orm import InMemoryVectorStore, VectorMetric, VectorRepository, VectorRecord\n\nstore = InMemoryVectorStore()\nrepo = VectorRepository(store, \"items\", dimension=3, metric=VectorMetric.COSINE)\nrepo.upsert([VectorRecord(id=\"1\", vector=[0.1, 0.2, 0.3])])\nhits = repo.query([0.1, 0.2, 0.25], top_k=5)\n</code></pre>"},{"location":"#quick-usage-async-vector","title":"Quick usage (Async Vector)","text":"<pre><code>import asyncio\nfrom mini_orm import AsyncVectorRepository, InMemoryVectorStore, VectorRecord\n\nasync def main() -&gt; None:\n    store = InMemoryVectorStore()\n    repo = AsyncVectorRepository(store, \"items\", dimension=3)\n    await repo.upsert([VectorRecord(id=\"1\", vector=[0.1, 0.2, 0.3])])\n    hits = await repo.query([0.1, 0.2, 0.25], top_k=5)\n    print(hits)\n\nasyncio.run(main())\n</code></pre>"},{"location":"#run-tests","title":"Run tests","text":"<pre><code>make test\nmake test-vector\n</code></pre>"},{"location":"#continue-reading","title":"Continue reading","text":"<ul> <li>Getting Started</li> <li>SQL Overview</li> <li>Vector Overview</li> <li>API Reference</li> </ul>"},{"location":"development/","title":"Development","text":""},{"location":"development/#run-tests","title":"Run tests","text":"<pre><code>make test\nmake test-vector\n</code></pre>"},{"location":"development/#start-external-services-for-examplestests","title":"Start external services for examples/tests","text":"<p><code>docker-compose.yml</code> includes:</p> <ul> <li>PostgreSQL + pgvector (<code>postgres</code> service)</li> <li>MySQL (<code>mysql</code> service)</li> <li>Qdrant (<code>qdrant</code> service)</li> <li>Chroma (<code>chroma</code> service)</li> </ul> <p>Start services:</p> <pre><code>make compose-up\nmake compose-ps\n</code></pre> <p>Stop services:</p> <pre><code>make compose-down\n</code></pre> <p>If you need to reset DB data volumes:</p> <pre><code>make compose-reset\n</code></pre> <p>Run host-server vector integration tests (Qdrant/Chroma/PgVector):</p> <pre><code># Required for tests.test_vector_pgvector_store:\nexport MINI_ORM_PG_HOST=localhost\nexport MINI_ORM_PG_PORT=5432\nexport MINI_ORM_PG_USER=postgres\nexport MINI_ORM_PG_PASSWORD=password\nexport MINI_ORM_PG_DATABASE=postgres\n\nmake test-vector-host\n</code></pre> <p>The target above automatically sets <code>MINI_ORM_VECTOR_HOST_TESTS=1</code> (<code>RUN_HOST_VECTOR_TESTS</code> in the test modules is derived from this flag).</p> <p>Run only PgVector host SQL+vector integration test:</p> <pre><code>make test-pgvector-host\n</code></pre> <p>Vector tests are split by backend for easier observation:</p> <ul> <li><code>tests/test_vector_inmemory_repository.py</code></li> <li><code>tests/test_vector_pgvector_store.py</code></li> <li><code>tests/test_vector_qdrant_store.py</code></li> <li><code>tests/test_vector_chroma_store.py</code></li> <li><code>tests/test_vector_faiss_store.py</code></li> </ul>"},{"location":"development/#build-library-artifacts","title":"Build library artifacts","text":"<pre><code>make build-lib\n</code></pre> <p>Artifacts are generated under <code>dist/</code> (<code>.whl</code> and <code>.tar.gz</code>).</p>"},{"location":"development/#publish-artifacts","title":"Publish artifacts","text":"<pre><code>make release-check\nmake release-lib\n</code></pre>"},{"location":"development/#build-docs-locally","title":"Build docs locally","text":"<pre><code>make deps-docs\nmkdocs serve\n</code></pre>"},{"location":"development/#project-layout","title":"Project layout","text":"<pre><code>mini_orm/\n  core/            # business logic, contracts, query/schema/repository\n  ports/           # adapters: SQL DB-API and vector backends\ndocs/              # MkDocs source\ntests/             # unit tests\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> </ul>"},{"location":"getting-started/#install-documentation-dependencies","title":"Install documentation dependencies","text":"<pre><code>pip install -r requirements-docs.txt\n</code></pre> <p>For runtime SQL usage, install your DB-API driver (for example <code>sqlite3</code> is built in, <code>psycopg</code>, <code>mysqlclient</code>, etc.).</p> <p>For Postgres/MySQL/Qdrant/Chroma examples and integration tests that need running database services, you can start the bundled compose stack:</p> <pre><code>make compose-up\nmake compose-ps\n</code></pre> <p>Or use raw Docker Compose commands:</p> <pre><code>docker compose up -d\ndocker compose ps\n</code></pre> <p>For Qdrant support:</p> <pre><code>pip install qdrant-client\n</code></pre> <p>For Chroma support:</p> <pre><code>pip install chromadb\n</code></pre> <p>For Faiss support:</p> <pre><code>pip install faiss-cpu numpy\n</code></pre>"},{"location":"getting-started/#quick-start-sqlite","title":"Quick start (SQLite)","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Optional\nimport sqlite3\n\nfrom mini_orm import Database, SQLiteDialect, Repository, C, apply_schema\n\n@dataclass\nclass User:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    email: str = field(default=\"\", metadata={\"index\": True})\n\nconn = sqlite3.connect(\":memory:\")\ndb = Database(conn, SQLiteDialect())\nrepo = Repository[User](db, User)\n\napply_schema(db, User)\nrepo.insert(User(email=\"alice@example.com\"))\nrows = repo.list(where=C.eq(\"email\", \"alice@example.com\"))\n</code></pre>"},{"location":"getting-started/#quick-start-async-sql-same-api-names","title":"Quick start (Async SQL, same API names)","text":"<pre><code>import asyncio\nimport sqlite3\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n\nfrom mini_orm import C, AsyncDatabase, AsyncRepository, SQLiteDialect, apply_schema_async\n\n@dataclass\nclass User:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    email: str = field(default=\"\", metadata={\"index\": True})\n\nasync def main() -&gt; None:\n    conn = sqlite3.connect(\":memory:\")\n    db = AsyncDatabase(conn, SQLiteDialect())\n    await apply_schema_async(db, User)\n    repo = AsyncRepository[User](db, User)\n\n    await repo.insert(User(email=\"alice@example.com\"))\n    rows = await repo.list(where=C.eq(\"email\", \"alice@example.com\"))\n    print(rows)\n    conn.close()\n\nasyncio.run(main())\n</code></pre> <p>Async SQL keeps the same repository method names as sync (<code>insert</code>, <code>get</code>, <code>list</code>, <code>update</code>, <code>delete</code>, <code>count</code>, <code>exists</code>, <code>create</code>, <code>get_related</code>, ...), only adding <code>await</code> and <code>async with</code>.</p>"},{"location":"getting-started/#connection-pooling-guards-poolconnector","title":"Connection pooling guards (<code>PoolConnector</code>)","text":"<pre><code>import sqlite3\nfrom mini_orm import Database, PoolConnector, SQLiteDialect\n\npool = PoolConnector(\n    sqlite3.connect,\n    \"file:appdb?mode=memory&amp;cache=shared\",\n    uri=True,\n    check_same_thread=False,\n    max_size=4,\n    transaction_guard=\"rollback\",\n    strict_pool=False,\n)\ndb = Database(pool, SQLiteDialect())\n</code></pre> <p>Safety defaults: - SQLite private memory (<code>:memory:</code>) is blocked for <code>max_size &gt; 1</code>. - SQLite with <code>max_size &gt; 1</code> requires <code>check_same_thread=False</code>. - On release, dirty transaction behavior is policy-based via <code>transaction_guard</code>:   - <code>raise</code>: raise error on dirty transaction.   - <code>ignore</code>: skip cleanup.   - <code>rollback</code> / <code>discard</code>: perform cleanup logic (and <code>discard</code> closes the connection).</p>"},{"location":"getting-started/#quick-relation-setup-metadata-based","title":"Quick relation setup (metadata-based)","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Optional\n\n@dataclass\nclass Author:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    name: str = \"\"\n\n@dataclass\nclass Post:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    author_id: Optional[int] = field(\n        default=None,\n        metadata={\n            \"fk\": (Author, \"id\"),\n            \"relation\": \"author\",     # optional\n            \"related_name\": \"posts\",  # optional\n        },\n    )\n    title: str = \"\"\n</code></pre> <p>From this metadata, mini_orm infers: - <code>Post.author</code> (<code>belongs_to</code>) - <code>Author.posts</code> (<code>has_many</code>)</p> <p>Then use: - <code>repo.create(..., relations=...)</code> for nested create - <code>repo.get_related(...)</code> / <code>repo.list_related(...)</code> for eager loading</p> <p>For full options and troubleshooting, see <code>docs/sql/repository.md</code>.</p>"},{"location":"getting-started/#quick-codec-setup-enumjson","title":"Quick codec setup (Enum/JSON)","text":"<p>Before calling <code>repo.insert(...)</code> / <code>repo.list(...)</code>, obtain a <code>Repository[Article]</code> instance from your MiniORM database/session and bind it to <code>repo</code>.</p> <pre><code>from dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Optional\n\nfrom mini_orm import C\n\nclass Status(str, Enum):\n    DRAFT = \"draft\"\n    PUBLISHED = \"published\"\n\n@dataclass\nclass Article:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    status: Status = Status.DRAFT\n    payload: dict[str, Any] = field(default_factory=dict)  # auto JSON codec\n    tags: list[str] = field(default_factory=list)          # auto JSON codec\n    extra: Any = field(default_factory=dict, metadata={\"codec\": \"json\"})  # explicit codec\n\nrepo.insert(Article(status=Status.PUBLISHED, payload={\"views\": 1}, tags=[\"orm\"]))\nloaded = repo.list(where=C.eq(\"status\", Status.PUBLISHED))[0]\n</code></pre>"},{"location":"getting-started/#quick-start-async-vector-same-api-names","title":"Quick start (Async Vector, same API names)","text":"<pre><code>import asyncio\n\nfrom mini_orm import AsyncVectorRepository, InMemoryVectorStore, VectorRecord\n\nasync def main() -&gt; None:\n    store = InMemoryVectorStore()\n    repo = AsyncVectorRepository(store, \"users\", dimension=3)\n\n    await repo.upsert(\n        [\n            VectorRecord(id=\"u1\", vector=[0.1, 0.2, 0.3], payload={\"name\": \"alice\"}),\n            VectorRecord(id=\"u2\", vector=[0.2, 0.1, 0.5], payload={\"name\": \"bob\"}),\n        ]\n    )\n    hits = await repo.query([0.1, 0.2, 0.25], top_k=2)\n    print(hits)\n\nasyncio.run(main())\n</code></pre> <p>Async vector keeps method names from sync (<code>create_collection</code>, <code>upsert</code>, <code>query</code>, <code>fetch</code>, <code>delete</code>), only adding <code>await</code>.</p>"},{"location":"getting-started/#dataclass-input-validation-optional","title":"Dataclass Input Validation (Optional)","text":"<p>Use <code>ValidatedModel</code> when you want pydantic-like runtime checks during dataclass construction.</p> <pre><code>from dataclasses import dataclass, field\n\nfrom mini_orm import ValidatedModel, ValidationError\n\n@dataclass\nclass CreateUserInput(ValidatedModel):\n    email: str = field(default=\"\", metadata={\"non_empty\": True, \"pattern\": r\"[^@]+@[^@]+\\.[^@]+\"})\n    age: int = field(default=0, metadata={\"ge\": 0, \"le\": 130})\n\ntry:\n    CreateUserInput(email=\"bad-email\", age=-1)\nexcept ValidationError as exc:\n    print(\"Validation error:\", exc)\n</code></pre>"},{"location":"getting-started/#build-documentation","title":"Build documentation","text":"<pre><code>mkdocs serve\n</code></pre> <p>or:</p> <pre><code>mkdocs build\n</code></pre>"},{"location":"getting-started/#useful-make-targets","title":"Useful Make targets","text":"<pre><code>make help\nmake test\nmake test-vector\nmake test-vector-host\nmake test-pgvector-host\nmake compose-down\n</code></pre>"},{"location":"api/core/","title":"Core API","text":""},{"location":"api/core/#mini_ormcoreconditions","title":"<code>mini_orm.core.conditions</code>","text":""},{"location":"api/core/#mini_orm.core.conditions","title":"<code>mini_orm.core.conditions</code>","text":"<p>Query condition primitives for repository filtering and sorting.</p>"},{"location":"api/core/#mini_orm.core.conditions.Condition","title":"<code>Condition</code>  <code>dataclass</code>","text":"<p>Represents one SQL condition expression.</p> <p>Attributes:</p> Name Type Description <code>col</code> <code>str</code> <p>Raw column name.</p> <code>op</code> <code>str</code> <p>SQL operator (for example <code>=</code>, <code>IN</code>, <code>IS NULL</code>).</p> <code>value</code> <code>Any</code> <p>Scalar value for binary operators.</p> <code>values</code> <code>Optional[Sequence[Any]]</code> <p>Sequence value for <code>IN</code>.</p> <code>is_unary</code> <code>bool</code> <p>Whether the operator is unary (<code>IS NULL</code>, <code>IS NOT NULL</code>).</p>"},{"location":"api/core/#mini_orm.core.conditions.ConditionGroup","title":"<code>ConditionGroup</code>  <code>dataclass</code>","text":"<p>Represents a grouped logical expression (<code>AND</code>/<code>OR</code>).</p>"},{"location":"api/core/#mini_orm.core.conditions.NotCondition","title":"<code>NotCondition</code>  <code>dataclass</code>","text":"<p>Represents a negated expression.</p>"},{"location":"api/core/#mini_orm.core.conditions.C","title":"<code>C</code>","text":"<p>Fluent condition factory methods.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.eq","title":"<code>eq(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col = value</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.ne","title":"<code>ne(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &lt;&gt; value</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.lt","title":"<code>lt(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &lt; value</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.le","title":"<code>le(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &lt;= value</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.gt","title":"<code>gt(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &gt; value</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.ge","title":"<code>ge(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &gt;= value</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.like","title":"<code>like(col, pattern)</code>  <code>staticmethod</code>","text":"<p>Build <code>col LIKE pattern</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.is_null","title":"<code>is_null(col)</code>  <code>staticmethod</code>","text":"<p>Build <code>col IS NULL</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.is_not_null","title":"<code>is_not_null(col)</code>  <code>staticmethod</code>","text":"<p>Build <code>col IS NOT NULL</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.in_","title":"<code>in_(col, values)</code>  <code>staticmethod</code>","text":"<p>Build <code>col IN (...)</code> condition.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.and_","title":"<code>and_(*items)</code>  <code>staticmethod</code>","text":"<p>Build a grouped <code>AND</code> expression.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.or_","title":"<code>or_(*items)</code>  <code>staticmethod</code>","text":"<p>Build a grouped <code>OR</code> expression.</p>"},{"location":"api/core/#mini_orm.core.conditions.C.not_","title":"<code>not_(item)</code>  <code>staticmethod</code>","text":"<p>Build a negated expression (<code>NOT (...)</code>).</p>"},{"location":"api/core/#mini_orm.core.conditions.OrderBy","title":"<code>OrderBy</code>  <code>dataclass</code>","text":"<p>Represents one ordering expression.</p>"},{"location":"api/core/#mini_ormcorequery_builder","title":"<code>mini_orm.core.query_builder</code>","text":""},{"location":"api/core/#mini_orm.core.query_builder","title":"<code>mini_orm.core.query_builder</code>","text":"<p>SQL fragment builders for filtering, sorting, and paging.</p> <p>This module centralizes SQL string compilation from query inputs. It keeps <code>Repository</code> focused on orchestration while making SQL generation reusable and easy to extend.</p>"},{"location":"api/core/#mini_orm.core.query_builder.CompiledFragment","title":"<code>CompiledFragment</code>  <code>dataclass</code>","text":"<p>Represents a compiled SQL fragment with its bound parameters.</p>"},{"location":"api/core/#mini_orm.core.query_builder.compile_where","title":"<code>compile_where(where, dialect)</code>","text":"<p>Compile one or many conditions into a SQL <code>WHERE</code> fragment.</p> <p>Multiple conditions are combined using <code>AND</code>.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>WhereInput</code> <p>A single condition, a list of conditions, or <code>None</code>.</p> required <code>dialect</code> <code>DialectPort</code> <p>SQL dialect used for identifier quoting and placeholders.</p> required <p>Returns:</p> Type Description <code>CompiledFragment</code> <p>A compiled SQL fragment and parameters. Empty fragment if no condition.</p>"},{"location":"api/core/#mini_orm.core.query_builder.compile_order_by","title":"<code>compile_order_by(order_by, dialect)</code>","text":"<p>Compile <code>ORDER BY</code> clause from ordering inputs.</p> <p>Parameters:</p> Name Type Description Default <code>order_by</code> <code>Optional[Sequence[OrderBy]]</code> <p>Ordering expressions or <code>None</code>.</p> required <code>dialect</code> <code>DialectPort</code> <p>SQL dialect used for identifier quoting.</p> required <p>Returns:</p> Type Description <code>str</code> <p>SQL <code>ORDER BY</code> fragment or an empty string.</p>"},{"location":"api/core/#mini_orm.core.query_builder.append_limit_offset","title":"<code>append_limit_offset(sql, params, *, limit, offset, dialect)</code>","text":"<p>Append pagination clauses and merge parameters.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>Base SQL string.</p> required <code>params</code> <code>QueryParams</code> <p>Existing parameters from previous fragment compilation.</p> required <code>limit</code> <code>Optional[int]</code> <p>Optional row limit.</p> required <code>offset</code> <code>Optional[int]</code> <p>Optional row offset.</p> required <code>dialect</code> <code>DialectPort</code> <p>SQL dialect used for placeholder style.</p> required <p>Returns:</p> Type Description <code>Tuple[str, QueryParams]</code> <p>Updated SQL and merged parameters.</p>"},{"location":"api/core/#mini_ormcorecodecs","title":"<code>mini_orm.core.codecs</code>","text":""},{"location":"api/core/#mini_orm.core.codecs","title":"<code>mini_orm.core.codecs</code>","text":"<p>Model field codec helpers for DB serialization/deserialization.</p>"},{"location":"api/core/#mini_orm.core.codecs.serialize_model_value","title":"<code>serialize_model_value(cls, field_name, value)</code>","text":"<p>Serialize one model field value for DB writes.</p>"},{"location":"api/core/#mini_orm.core.codecs.deserialize_model_value","title":"<code>deserialize_model_value(cls, field_name, value)</code>","text":"<p>Deserialize one DB value into model field type.</p>"},{"location":"api/core/#mini_ormcoremodels","title":"<code>mini_orm.core.models</code>","text":""},{"location":"api/core/#mini_orm.core.models","title":"<code>mini_orm.core.models</code>","text":"<p>Model utilities for dataclass validation and mapping.</p>"},{"location":"api/core/#mini_orm.core.models.DataclassModel","title":"<code>DataclassModel</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for supported dataclass model types.</p>"},{"location":"api/core/#mini_orm.core.models.RelationType","title":"<code>RelationType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported model relation kinds.</p>"},{"location":"api/core/#mini_orm.core.models.RelationSpec","title":"<code>RelationSpec</code>  <code>dataclass</code>","text":"<p>Normalized relation definition attached to a model class.</p>"},{"location":"api/core/#mini_orm.core.models.require_dataclass_model","title":"<code>require_dataclass_model(cls)</code>","text":"<p>Validate that a class is a dataclass model.</p>"},{"location":"api/core/#mini_orm.core.models.table_name","title":"<code>table_name(model_or_cls)</code>","text":"<p>Resolve table name from model class or instance.</p> <p>Uses <code>__table__</code> override when present, otherwise lowercased class name.</p>"},{"location":"api/core/#mini_orm.core.models.model_fields","title":"<code>model_fields(cls)</code>","text":"<p>Return dataclass fields for a model type.</p>"},{"location":"api/core/#mini_orm.core.models.model_relations","title":"<code>model_relations(cls)</code>","text":"<p>Parse/derive model relations and validate relation specs.</p>"},{"location":"api/core/#mini_orm.core.models.pk_fields","title":"<code>pk_fields(cls)</code>","text":"<p>Return primary key fields defined with <code>metadata={'pk': True}</code>.</p>"},{"location":"api/core/#mini_orm.core.models.auto_pk_field","title":"<code>auto_pk_field(cls)</code>","text":"<p>Return auto primary key field if model has exactly one auto PK.</p>"},{"location":"api/core/#mini_orm.core.models.to_dict","title":"<code>to_dict(obj)</code>","text":"<p>Convert dataclass model instance to DB-ready dictionary.</p>"},{"location":"api/core/#mini_orm.core.models.row_to_model","title":"<code>row_to_model(cls, row)</code>","text":"<p>Map one DB row mapping to a model instance.</p>"},{"location":"api/core/#mini_ormcoremetadata","title":"<code>mini_orm.core.metadata</code>","text":""},{"location":"api/core/#mini_orm.core.metadata","title":"<code>mini_orm.core.metadata</code>","text":"<p>Model metadata extraction used by repository SQL generation.</p>"},{"location":"api/core/#mini_orm.core.metadata.ModelMetadata","title":"<code>ModelMetadata</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Normalized model description used by repository operations.</p>"},{"location":"api/core/#mini_orm.core.metadata.build_model_metadata","title":"<code>build_model_metadata(model)</code>","text":"<p>Build model metadata from dataclass annotations and field metadata.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>Dataclass model type.</p> required <p>Returns:</p> Type Description <code>ModelMetadata[T]</code> <p>Immutable metadata object used by <code>Repository</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model has zero or multiple primary key fields.</p>"},{"location":"api/core/#mini_ormcorevalidated_model","title":"<code>mini_orm.core.validated_model</code>","text":""},{"location":"api/core/#mini_orm.core.validated_model","title":"<code>mini_orm.core.validated_model</code>","text":"<p>Dataclass validation mixin for pydantic-like basic input checks.</p>"},{"location":"api/core/#mini_orm.core.validated_model.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when dataclass field validation fails.</p>"},{"location":"api/core/#mini_orm.core.validated_model.ValidatedModel","title":"<code>ValidatedModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for dataclasses that need runtime input validation.</p> <p>Usage: - Inherit this class and decorate child model with <code>@dataclass</code>. - Add field constraints in dataclass field metadata. - Optionally override <code>model_validate()</code> for model-level checks.</p>"},{"location":"api/core/#mini_orm.core.validated_model.ValidatedModel.model_validate","title":"<code>model_validate()</code>","text":"<p>Hook for model-level custom validation after field checks.</p>"},{"location":"api/core/#mini_ormcoreschemasschema","title":"<code>mini_orm.core.schemas.schema</code>","text":""},{"location":"api/core/#mini_orm.core.schemas.schema","title":"<code>mini_orm.core.schemas.schema</code>","text":"<p>Schema helpers for deriving and applying table/index SQL from models.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.validate_schema_conflict","title":"<code>validate_schema_conflict(schema_conflict)</code>","text":"<p>Validate schema conflict mode and return normalized value.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.create_table_sql","title":"<code>create_table_sql(cls, dialect, *, if_not_exists=False)</code>","text":"<p>Build <code>CREATE TABLE</code> statement for a dataclass model.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.create_index_sql","title":"<code>create_index_sql(cls, dialect, column, *, unique=False, name=None, if_not_exists=False)</code>","text":"<p>Build one single-column index SQL statement.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.create_indexes_sql","title":"<code>create_indexes_sql(cls, dialect, *, if_not_exists=False)</code>","text":"<p>Build index SQL statements from model field metadata and <code>__indexes__</code>.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.create_schema_sql","title":"<code>create_schema_sql(cls, dialect, *, if_not_exists=False)</code>","text":"<p>Build full schema SQL list (table first, then indexes).</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.apply_schema","title":"<code>apply_schema(db, cls, *, if_not_exists=False)</code>","text":"<p>Create table and all configured indexes for a model on a database.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.apply_schema_async","title":"<code>apply_schema_async(db, cls, *, if_not_exists=False)</code>  <code>async</code>","text":"<p>Async variant of <code>apply_schema</code> with identical SQL generation.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.ensure_schema","title":"<code>ensure_schema(db, cls, *, schema_conflict='raise')</code>","text":"<p>Ensure schema exists and sync additive changes for a model.</p> <p>Behavior: - Create table/indexes if table does not exist. - If table exists:   - Keep unchanged schema as-is.   - Add missing columns when possible.   - Create missing indexes and recreate changed index definitions. - For incompatible column changes (type/nullability/PK changes), behavior   is controlled by <code>schema_conflict</code>:   - <code>\"raise\"</code>: raise <code>ValueError</code>.   - <code>\"recreate\"</code>: drop and recreate table/indexes.</p>"},{"location":"api/core/#mini_orm.core.schemas.schema.ensure_schema_async","title":"<code>ensure_schema_async(db, cls, *, schema_conflict='raise')</code>  <code>async</code>","text":"<p>Async variant of <code>ensure_schema</code> with the same behavior.</p>"},{"location":"api/core/#mini_ormcorerepositoriesrepository","title":"<code>mini_orm.core.repositories.repository</code>","text":""},{"location":"api/core/#mini_orm.core.repositories.repository","title":"<code>mini_orm.core.repositories.repository</code>","text":"<p>Repository facade that composes CRUD and relation coordinators.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository","title":"<code>Repository</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>CRUD repository backed by a <code>DatabasePort</code> implementation.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.register","title":"<code>register(*, ensure=None)</code>","text":"<p>Register current model and optionally ensure schema.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.register_many","title":"<code>register_many(*, ensure=None)</code>","text":"<p>Single-model alias to mirror unified registration API shape.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.insert","title":"<code>insert(obj)</code>","text":"<p>Insert an object and populate auto primary key when available.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.update","title":"<code>update(obj)</code>","text":"<p>Update one row identified by model primary key.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.delete","title":"<code>delete(obj)</code>","text":"<p>Delete one row identified by model primary key.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.get","title":"<code>get(pk_value)</code>","text":"<p>Fetch one row by primary key and map it to the model type.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.list","title":"<code>list(where=None, order_by=None, limit=None, offset=None)</code>","text":"<p>List rows with optional filtering, sorting, and pagination.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.count","title":"<code>count(where=None)</code>","text":"<p>Count rows matching optional conditions.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.exists","title":"<code>exists(where=None)</code>","text":"<p>Return whether at least one row matches optional conditions.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.insert_many","title":"<code>insert_many(objects)</code>","text":"<p>Insert many objects and return inserted objects.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.create","title":"<code>create(obj, *, relations=None)</code>","text":"<p>Create one object and optionally create/link related records.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.get_related","title":"<code>get_related(pk_value, *, include)</code>","text":"<p>Get one record and requested relations in one result object.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.list_related","title":"<code>list_related(*, include, where=None, order_by=None, limit=None, offset=None)</code>","text":"<p>List records with requested related records.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.update_where","title":"<code>update_where(values, *, where)</code>","text":"<p>Update rows by conditions and return affected row count.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.delete_where","title":"<code>delete_where(*, where)</code>","text":"<p>Delete rows by conditions and return affected row count.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.Repository.get_or_create","title":"<code>get_or_create(*, lookup, defaults=None)</code>","text":"<p>Get first row by lookup fields or create a new object.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.UnifiedRepository","title":"<code>UnifiedRepository</code>","text":"<p>Route operations to cached <code>Repository[T]</code> instances by model class.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository.UnifiedRepository.repo","title":"<code>repo(model)</code>","text":"<p>Return cached repository for a dataclass model class.</p>"},{"location":"api/core/#mini_ormcorerepositoriesrepository_async","title":"<code>mini_orm.core.repositories.repository_async</code>","text":""},{"location":"api/core/#mini_orm.core.repositories.repository_async","title":"<code>mini_orm.core.repositories.repository_async</code>","text":"<p>Async repository facade that composes CRUD and relation coordinators.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository","title":"<code>AsyncRepository</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Async CRUD repository backed by an <code>AsyncDatabasePort</code> implementation.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.register","title":"<code>register(*, ensure=None)</code>  <code>async</code>","text":"<p>Register current model and optionally ensure schema.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.register_many","title":"<code>register_many(*, ensure=None)</code>  <code>async</code>","text":"<p>Single-model alias to mirror unified registration API shape.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.insert","title":"<code>insert(obj)</code>  <code>async</code>","text":"<p>Insert an object and populate auto primary key when available.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.update","title":"<code>update(obj)</code>  <code>async</code>","text":"<p>Update one row identified by model primary key.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.delete","title":"<code>delete(obj)</code>  <code>async</code>","text":"<p>Delete one row identified by model primary key.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.get","title":"<code>get(pk_value)</code>  <code>async</code>","text":"<p>Fetch one row by primary key and map it to the model type.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.list","title":"<code>list(where=None, order_by=None, limit=None, offset=None)</code>  <code>async</code>","text":"<p>List rows with optional filtering, sorting, and pagination.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.count","title":"<code>count(where=None)</code>  <code>async</code>","text":"<p>Count rows matching optional conditions.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.exists","title":"<code>exists(where=None)</code>  <code>async</code>","text":"<p>Return whether at least one row matches optional conditions.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.insert_many","title":"<code>insert_many(objects)</code>  <code>async</code>","text":"<p>Insert many objects and return inserted objects.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.create","title":"<code>create(obj, *, relations=None)</code>  <code>async</code>","text":"<p>Create one object and optionally create/link related records.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.get_related","title":"<code>get_related(pk_value, *, include)</code>  <code>async</code>","text":"<p>Get one record and requested relations in one result object.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.list_related","title":"<code>list_related(*, include, where=None, order_by=None, limit=None, offset=None)</code>  <code>async</code>","text":"<p>List records with requested related records.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.update_where","title":"<code>update_where(values, *, where)</code>  <code>async</code>","text":"<p>Update rows by conditions and return affected row count.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.delete_where","title":"<code>delete_where(*, where)</code>  <code>async</code>","text":"<p>Delete rows by conditions and return affected row count.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncRepository.get_or_create","title":"<code>get_or_create(*, lookup, defaults=None)</code>  <code>async</code>","text":"<p>Get first row by lookup fields or create a new object.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncUnifiedRepository","title":"<code>AsyncUnifiedRepository</code>","text":"<p>Route operations to cached <code>AsyncRepository[T]</code> instances by model class.</p>"},{"location":"api/core/#mini_orm.core.repositories.repository_async.AsyncUnifiedRepository.repo","title":"<code>repo(model)</code>","text":"<p>Return cached async repository for a dataclass model class.</p>"},{"location":"api/core/#mini_ormcorevectorsvector_types","title":"<code>mini_orm.core.vectors.vector_types</code>","text":""},{"location":"api/core/#mini_orm.core.vectors.vector_types","title":"<code>mini_orm.core.vectors.vector_types</code>","text":"<p>Shared vector entities used by vector ports and repositories.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_types.VectorRecord","title":"<code>VectorRecord</code>  <code>dataclass</code>","text":"<p>Represents one vector document stored in a vector database.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_types.VectorSearchResult","title":"<code>VectorSearchResult</code>  <code>dataclass</code>","text":"<p>Represents one scored search hit returned by vector similarity query.</p>"},{"location":"api/core/#mini_ormcorevectorsvector_codecs","title":"<code>mini_orm.core.vectors.vector_codecs</code>","text":""},{"location":"api/core/#mini_orm.core.vectors.vector_codecs","title":"<code>mini_orm.core.vectors.vector_codecs</code>","text":"<p>Payload codec helpers for vector repository I/O.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_codecs.VectorPayloadCodec","title":"<code>VectorPayloadCodec</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Codec interface for vector payload/filter serialization and deserialization.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_codecs.IdentityVectorPayloadCodec","title":"<code>IdentityVectorPayloadCodec</code>  <code>dataclass</code>","text":"<p>Default no-op payload codec.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_codecs.JsonVectorPayloadCodec","title":"<code>JsonVectorPayloadCodec</code>  <code>dataclass</code>","text":"<p>Codec that stores non-scalar payload values as tagged JSON strings.</p> <p>Scalar values (<code>None</code>, <code>bool</code>, <code>int</code>, <code>float</code>, and normal <code>str</code>) are kept as-is. Non-scalar values (for example <code>Enum</code>, <code>dict</code>, <code>list</code>, <code>datetime</code>, <code>Decimal</code>) are converted into prefixed JSON text and reconstructed on read.</p>"},{"location":"api/core/#mini_ormcorevectorsvector_repository","title":"<code>mini_orm.core.vectors.vector_repository</code>","text":""},{"location":"api/core/#mini_orm.core.vectors.vector_repository","title":"<code>mini_orm.core.vectors.vector_repository</code>","text":"<p>Repository abstraction for vector database operations.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository.VectorRepository","title":"<code>VectorRepository</code>","text":"<p>High-level vector collection operations backed by a vector store port.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository.VectorRepository.create_collection","title":"<code>create_collection(*, overwrite=False)</code>","text":"<p>Create or recreate collection explicitly.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository.VectorRepository.upsert","title":"<code>upsert(records)</code>","text":"<p>Insert or update vector records.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository.VectorRepository.query","title":"<code>query(vector, *, top_k=10, filters=None)</code>","text":"<p>Search nearest vectors in the collection.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository.VectorRepository.fetch","title":"<code>fetch(ids=None)</code>","text":"<p>Fetch records by ids, or fetch all when ids is None.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository.VectorRepository.delete","title":"<code>delete(ids)</code>","text":"<p>Delete records by ids and return number of deleted rows.</p>"},{"location":"api/core/#mini_ormcorevectorsvector_repository_async","title":"<code>mini_orm.core.vectors.vector_repository_async</code>","text":""},{"location":"api/core/#mini_orm.core.vectors.vector_repository_async","title":"<code>mini_orm.core.vectors.vector_repository_async</code>","text":"<p>Async repository abstraction for vector database operations.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository_async.AsyncVectorRepository","title":"<code>AsyncVectorRepository</code>","text":"<p>Async high-level vector collection operations backed by a vector store port.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository_async.AsyncVectorRepository.create_collection","title":"<code>create_collection(*, overwrite=False)</code>  <code>async</code>","text":"<p>Create or recreate collection explicitly.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository_async.AsyncVectorRepository.upsert","title":"<code>upsert(records)</code>  <code>async</code>","text":"<p>Insert or update vector records.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository_async.AsyncVectorRepository.query","title":"<code>query(vector, *, top_k=10, filters=None)</code>  <code>async</code>","text":"<p>Search nearest vectors in the collection.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository_async.AsyncVectorRepository.fetch","title":"<code>fetch(ids=None)</code>  <code>async</code>","text":"<p>Fetch records by ids, or fetch all when ids is None.</p>"},{"location":"api/core/#mini_orm.core.vectors.vector_repository_async.AsyncVectorRepository.delete","title":"<code>delete(ids)</code>  <code>async</code>","text":"<p>Delete records by ids and return number of deleted rows.</p>"},{"location":"api/package/","title":"Package API","text":""},{"location":"api/package/#mini_orm","title":"<code>mini_orm</code>","text":"<p>Mini ORM package exports.</p>"},{"location":"api/package/#mini_orm.C","title":"<code>C</code>","text":"<p>Fluent condition factory methods.</p>"},{"location":"api/package/#mini_orm.C.eq","title":"<code>eq(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col = value</code> condition.</p>"},{"location":"api/package/#mini_orm.C.ne","title":"<code>ne(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &lt;&gt; value</code> condition.</p>"},{"location":"api/package/#mini_orm.C.lt","title":"<code>lt(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &lt; value</code> condition.</p>"},{"location":"api/package/#mini_orm.C.le","title":"<code>le(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &lt;= value</code> condition.</p>"},{"location":"api/package/#mini_orm.C.gt","title":"<code>gt(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &gt; value</code> condition.</p>"},{"location":"api/package/#mini_orm.C.ge","title":"<code>ge(col, val)</code>  <code>staticmethod</code>","text":"<p>Build <code>col &gt;= value</code> condition.</p>"},{"location":"api/package/#mini_orm.C.like","title":"<code>like(col, pattern)</code>  <code>staticmethod</code>","text":"<p>Build <code>col LIKE pattern</code> condition.</p>"},{"location":"api/package/#mini_orm.C.is_null","title":"<code>is_null(col)</code>  <code>staticmethod</code>","text":"<p>Build <code>col IS NULL</code> condition.</p>"},{"location":"api/package/#mini_orm.C.is_not_null","title":"<code>is_not_null(col)</code>  <code>staticmethod</code>","text":"<p>Build <code>col IS NOT NULL</code> condition.</p>"},{"location":"api/package/#mini_orm.C.in_","title":"<code>in_(col, values)</code>  <code>staticmethod</code>","text":"<p>Build <code>col IN (...)</code> condition.</p>"},{"location":"api/package/#mini_orm.C.and_","title":"<code>and_(*items)</code>  <code>staticmethod</code>","text":"<p>Build a grouped <code>AND</code> expression.</p>"},{"location":"api/package/#mini_orm.C.or_","title":"<code>or_(*items)</code>  <code>staticmethod</code>","text":"<p>Build a grouped <code>OR</code> expression.</p>"},{"location":"api/package/#mini_orm.C.not_","title":"<code>not_(item)</code>  <code>staticmethod</code>","text":"<p>Build a negated expression (<code>NOT (...)</code>).</p>"},{"location":"api/package/#mini_orm.Condition","title":"<code>Condition</code>  <code>dataclass</code>","text":"<p>Represents one SQL condition expression.</p> <p>Attributes:</p> Name Type Description <code>col</code> <code>str</code> <p>Raw column name.</p> <code>op</code> <code>str</code> <p>SQL operator (for example <code>=</code>, <code>IN</code>, <code>IS NULL</code>).</p> <code>value</code> <code>Any</code> <p>Scalar value for binary operators.</p> <code>values</code> <code>Optional[Sequence[Any]]</code> <p>Sequence value for <code>IN</code>.</p> <code>is_unary</code> <code>bool</code> <p>Whether the operator is unary (<code>IS NULL</code>, <code>IS NOT NULL</code>).</p>"},{"location":"api/package/#mini_orm.ConditionGroup","title":"<code>ConditionGroup</code>  <code>dataclass</code>","text":"<p>Represents a grouped logical expression (<code>AND</code>/<code>OR</code>).</p>"},{"location":"api/package/#mini_orm.IndexSpec","title":"<code>IndexSpec</code>  <code>dataclass</code>","text":"<p>Represents one index definition.</p>"},{"location":"api/package/#mini_orm.NotCondition","title":"<code>NotCondition</code>  <code>dataclass</code>","text":"<p>Represents a negated expression.</p>"},{"location":"api/package/#mini_orm.OrderBy","title":"<code>OrderBy</code>  <code>dataclass</code>","text":"<p>Represents one ordering expression.</p>"},{"location":"api/package/#mini_orm.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when dataclass field validation fails.</p>"},{"location":"api/package/#mini_orm.ValidatedModel","title":"<code>ValidatedModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for dataclasses that need runtime input validation.</p> <p>Usage: - Inherit this class and decorate child model with <code>@dataclass</code>. - Add field constraints in dataclass field metadata. - Optionally override <code>model_validate()</code> for model-level checks.</p>"},{"location":"api/package/#mini_orm.ValidatedModel.model_validate","title":"<code>model_validate()</code>","text":"<p>Hook for model-level custom validation after field checks.</p>"},{"location":"api/package/#mini_orm.RelatedResult","title":"<code>RelatedResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>One record and its requested related records.</p>"},{"location":"api/package/#mini_orm.AsyncRelatedResult","title":"<code>AsyncRelatedResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>One record and its requested related records.</p>"},{"location":"api/package/#mini_orm.RelationSpec","title":"<code>RelationSpec</code>  <code>dataclass</code>","text":"<p>Normalized relation definition attached to a model class.</p>"},{"location":"api/package/#mini_orm.RelationType","title":"<code>RelationType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported model relation kinds.</p>"},{"location":"api/package/#mini_orm.Repository","title":"<code>Repository</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>CRUD repository backed by a <code>DatabasePort</code> implementation.</p>"},{"location":"api/package/#mini_orm.Repository.register","title":"<code>register(*, ensure=None)</code>","text":"<p>Register current model and optionally ensure schema.</p>"},{"location":"api/package/#mini_orm.Repository.register_many","title":"<code>register_many(*, ensure=None)</code>","text":"<p>Single-model alias to mirror unified registration API shape.</p>"},{"location":"api/package/#mini_orm.Repository.insert","title":"<code>insert(obj)</code>","text":"<p>Insert an object and populate auto primary key when available.</p>"},{"location":"api/package/#mini_orm.Repository.update","title":"<code>update(obj)</code>","text":"<p>Update one row identified by model primary key.</p>"},{"location":"api/package/#mini_orm.Repository.delete","title":"<code>delete(obj)</code>","text":"<p>Delete one row identified by model primary key.</p>"},{"location":"api/package/#mini_orm.Repository.get","title":"<code>get(pk_value)</code>","text":"<p>Fetch one row by primary key and map it to the model type.</p>"},{"location":"api/package/#mini_orm.Repository.list","title":"<code>list(where=None, order_by=None, limit=None, offset=None)</code>","text":"<p>List rows with optional filtering, sorting, and pagination.</p>"},{"location":"api/package/#mini_orm.Repository.count","title":"<code>count(where=None)</code>","text":"<p>Count rows matching optional conditions.</p>"},{"location":"api/package/#mini_orm.Repository.exists","title":"<code>exists(where=None)</code>","text":"<p>Return whether at least one row matches optional conditions.</p>"},{"location":"api/package/#mini_orm.Repository.insert_many","title":"<code>insert_many(objects)</code>","text":"<p>Insert many objects and return inserted objects.</p>"},{"location":"api/package/#mini_orm.Repository.create","title":"<code>create(obj, *, relations=None)</code>","text":"<p>Create one object and optionally create/link related records.</p>"},{"location":"api/package/#mini_orm.Repository.get_related","title":"<code>get_related(pk_value, *, include)</code>","text":"<p>Get one record and requested relations in one result object.</p>"},{"location":"api/package/#mini_orm.Repository.list_related","title":"<code>list_related(*, include, where=None, order_by=None, limit=None, offset=None)</code>","text":"<p>List records with requested related records.</p>"},{"location":"api/package/#mini_orm.Repository.update_where","title":"<code>update_where(values, *, where)</code>","text":"<p>Update rows by conditions and return affected row count.</p>"},{"location":"api/package/#mini_orm.Repository.delete_where","title":"<code>delete_where(*, where)</code>","text":"<p>Delete rows by conditions and return affected row count.</p>"},{"location":"api/package/#mini_orm.Repository.get_or_create","title":"<code>get_or_create(*, lookup, defaults=None)</code>","text":"<p>Get first row by lookup fields or create a new object.</p>"},{"location":"api/package/#mini_orm.UnifiedRepository","title":"<code>UnifiedRepository</code>","text":"<p>Route operations to cached <code>Repository[T]</code> instances by model class.</p>"},{"location":"api/package/#mini_orm.UnifiedRepository.repo","title":"<code>repo(model)</code>","text":"<p>Return cached repository for a dataclass model class.</p>"},{"location":"api/package/#mini_orm.AsyncRepository","title":"<code>AsyncRepository</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Async CRUD repository backed by an <code>AsyncDatabasePort</code> implementation.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.register","title":"<code>register(*, ensure=None)</code>  <code>async</code>","text":"<p>Register current model and optionally ensure schema.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.register_many","title":"<code>register_many(*, ensure=None)</code>  <code>async</code>","text":"<p>Single-model alias to mirror unified registration API shape.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.insert","title":"<code>insert(obj)</code>  <code>async</code>","text":"<p>Insert an object and populate auto primary key when available.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.update","title":"<code>update(obj)</code>  <code>async</code>","text":"<p>Update one row identified by model primary key.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.delete","title":"<code>delete(obj)</code>  <code>async</code>","text":"<p>Delete one row identified by model primary key.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.get","title":"<code>get(pk_value)</code>  <code>async</code>","text":"<p>Fetch one row by primary key and map it to the model type.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.list","title":"<code>list(where=None, order_by=None, limit=None, offset=None)</code>  <code>async</code>","text":"<p>List rows with optional filtering, sorting, and pagination.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.count","title":"<code>count(where=None)</code>  <code>async</code>","text":"<p>Count rows matching optional conditions.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.exists","title":"<code>exists(where=None)</code>  <code>async</code>","text":"<p>Return whether at least one row matches optional conditions.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.insert_many","title":"<code>insert_many(objects)</code>  <code>async</code>","text":"<p>Insert many objects and return inserted objects.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.create","title":"<code>create(obj, *, relations=None)</code>  <code>async</code>","text":"<p>Create one object and optionally create/link related records.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.get_related","title":"<code>get_related(pk_value, *, include)</code>  <code>async</code>","text":"<p>Get one record and requested relations in one result object.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.list_related","title":"<code>list_related(*, include, where=None, order_by=None, limit=None, offset=None)</code>  <code>async</code>","text":"<p>List records with requested related records.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.update_where","title":"<code>update_where(values, *, where)</code>  <code>async</code>","text":"<p>Update rows by conditions and return affected row count.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.delete_where","title":"<code>delete_where(*, where)</code>  <code>async</code>","text":"<p>Delete rows by conditions and return affected row count.</p>"},{"location":"api/package/#mini_orm.AsyncRepository.get_or_create","title":"<code>get_or_create(*, lookup, defaults=None)</code>  <code>async</code>","text":"<p>Get first row by lookup fields or create a new object.</p>"},{"location":"api/package/#mini_orm.AsyncUnifiedRepository","title":"<code>AsyncUnifiedRepository</code>","text":"<p>Route operations to cached <code>AsyncRepository[T]</code> instances by model class.</p>"},{"location":"api/package/#mini_orm.AsyncUnifiedRepository.repo","title":"<code>repo(model)</code>","text":"<p>Return cached async repository for a dataclass model class.</p>"},{"location":"api/package/#mini_orm.IdentityVectorPayloadCodec","title":"<code>IdentityVectorPayloadCodec</code>  <code>dataclass</code>","text":"<p>Default no-op payload codec.</p>"},{"location":"api/package/#mini_orm.JsonVectorPayloadCodec","title":"<code>JsonVectorPayloadCodec</code>  <code>dataclass</code>","text":"<p>Codec that stores non-scalar payload values as tagged JSON strings.</p> <p>Scalar values (<code>None</code>, <code>bool</code>, <code>int</code>, <code>float</code>, and normal <code>str</code>) are kept as-is. Non-scalar values (for example <code>Enum</code>, <code>dict</code>, <code>list</code>, <code>datetime</code>, <code>Decimal</code>) are converted into prefixed JSON text and reconstructed on read.</p>"},{"location":"api/package/#mini_orm.VectorPayloadCodec","title":"<code>VectorPayloadCodec</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Codec interface for vector payload/filter serialization and deserialization.</p>"},{"location":"api/package/#mini_orm.VectorIdPolicy","title":"<code>VectorIdPolicy</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Identifier policy used by a vector backend.</p>"},{"location":"api/package/#mini_orm.VectorMetric","title":"<code>VectorMetric</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported normalized vector metric values.</p>"},{"location":"api/package/#mini_orm.VectorRecord","title":"<code>VectorRecord</code>  <code>dataclass</code>","text":"<p>Represents one vector document stored in a vector database.</p>"},{"location":"api/package/#mini_orm.VectorRepository","title":"<code>VectorRepository</code>","text":"<p>High-level vector collection operations backed by a vector store port.</p>"},{"location":"api/package/#mini_orm.VectorRepository.create_collection","title":"<code>create_collection(*, overwrite=False)</code>","text":"<p>Create or recreate collection explicitly.</p>"},{"location":"api/package/#mini_orm.VectorRepository.upsert","title":"<code>upsert(records)</code>","text":"<p>Insert or update vector records.</p>"},{"location":"api/package/#mini_orm.VectorRepository.query","title":"<code>query(vector, *, top_k=10, filters=None)</code>","text":"<p>Search nearest vectors in the collection.</p>"},{"location":"api/package/#mini_orm.VectorRepository.fetch","title":"<code>fetch(ids=None)</code>","text":"<p>Fetch records by ids, or fetch all when ids is None.</p>"},{"location":"api/package/#mini_orm.VectorRepository.delete","title":"<code>delete(ids)</code>","text":"<p>Delete records by ids and return number of deleted rows.</p>"},{"location":"api/package/#mini_orm.AsyncVectorRepository","title":"<code>AsyncVectorRepository</code>","text":"<p>Async high-level vector collection operations backed by a vector store port.</p>"},{"location":"api/package/#mini_orm.AsyncVectorRepository.create_collection","title":"<code>create_collection(*, overwrite=False)</code>  <code>async</code>","text":"<p>Create or recreate collection explicitly.</p>"},{"location":"api/package/#mini_orm.AsyncVectorRepository.upsert","title":"<code>upsert(records)</code>  <code>async</code>","text":"<p>Insert or update vector records.</p>"},{"location":"api/package/#mini_orm.AsyncVectorRepository.query","title":"<code>query(vector, *, top_k=10, filters=None)</code>  <code>async</code>","text":"<p>Search nearest vectors in the collection.</p>"},{"location":"api/package/#mini_orm.AsyncVectorRepository.fetch","title":"<code>fetch(ids=None)</code>  <code>async</code>","text":"<p>Fetch records by ids, or fetch all when ids is None.</p>"},{"location":"api/package/#mini_orm.AsyncVectorRepository.delete","title":"<code>delete(ids)</code>  <code>async</code>","text":"<p>Delete records by ids and return number of deleted rows.</p>"},{"location":"api/package/#mini_orm.VectorSearchResult","title":"<code>VectorSearchResult</code>  <code>dataclass</code>","text":"<p>Represents one scored search hit returned by vector similarity query.</p>"},{"location":"api/package/#mini_orm.ChromaVectorStore","title":"<code>ChromaVectorStore</code>","text":"<p>Vector store adapter for ChromaDB.</p>"},{"location":"api/package/#mini_orm.AsyncDatabase","title":"<code>AsyncDatabase</code>","text":"<p>Async database wrapper that normalizes execute and row mapping behavior.</p>"},{"location":"api/package/#mini_orm.AsyncDatabase.transaction","title":"<code>transaction()</code>  <code>async</code>","text":"<p>Provide async commit/rollback transaction scope.</p>"},{"location":"api/package/#mini_orm.AsyncDatabase.execute","title":"<code>execute(sql, params=None)</code>  <code>async</code>","text":"<p>Execute SQL with optional parameters and return cursor.</p>"},{"location":"api/package/#mini_orm.AsyncDatabase.fetchone","title":"<code>fetchone(sql, params=None)</code>  <code>async</code>","text":"<p>Execute query and return one normalized row mapping.</p>"},{"location":"api/package/#mini_orm.AsyncDatabase.fetchall","title":"<code>fetchall(sql, params=None)</code>  <code>async</code>","text":"<p>Execute query and return all rows as normalized mappings.</p>"},{"location":"api/package/#mini_orm.AsyncDatabase.close","title":"<code>close(*, close_pool=False)</code>","text":"<p>Release/close underlying connection.</p> <p>Parameters:</p> Name Type Description Default <code>close_pool</code> <code>bool</code> <p>Also close pooled connector when this adapter uses <code>PoolConnector</code>.</p> <code>False</code>"},{"location":"api/package/#mini_orm.AsyncDatabase.aclose","title":"<code>aclose(*, close_pool=False)</code>  <code>async</code>","text":"<p>Async release/close underlying connection.</p> <p>Parameters:</p> Name Type Description Default <code>close_pool</code> <code>bool</code> <p>Also close pooled connector when this adapter uses <code>PoolConnector</code>.</p> <code>False</code>"},{"location":"api/package/#mini_orm.Database","title":"<code>Database</code>","text":"<p>Thin DB-API wrapper that normalizes execute and row mapping behavior.</p>"},{"location":"api/package/#mini_orm.Database.transaction","title":"<code>transaction()</code>","text":"<p>Provide commit/rollback transaction scope.</p>"},{"location":"api/package/#mini_orm.Database.execute","title":"<code>execute(sql, params=None)</code>","text":"<p>Execute SQL with optional parameters and return cursor.</p>"},{"location":"api/package/#mini_orm.Database.fetchone","title":"<code>fetchone(sql, params=None)</code>","text":"<p>Execute query and return one normalized row mapping.</p>"},{"location":"api/package/#mini_orm.Database.fetchall","title":"<code>fetchall(sql, params=None)</code>","text":"<p>Execute query and return all rows as normalized mappings.</p>"},{"location":"api/package/#mini_orm.Database.close","title":"<code>close(*, close_pool=False)</code>","text":"<p>Release/close underlying connection.</p> <p>Parameters:</p> Name Type Description Default <code>close_pool</code> <code>bool</code> <p>Also close pooled connector when this adapter uses <code>PoolConnector</code>.</p> <code>False</code>"},{"location":"api/package/#mini_orm.Dialect","title":"<code>Dialect</code>","text":"<p>Base dialect that defines SQL quoting and placeholder behavior.</p>"},{"location":"api/package/#mini_orm.Dialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/package/#mini_orm.Dialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/package/#mini_orm.Dialect.auto_pk_sql","title":"<code>auto_pk_sql(pk_name)</code>","text":"<p>Return SQL fragment for auto-increment primary key column.</p>"},{"location":"api/package/#mini_orm.Dialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/package/#mini_orm.Dialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/package/#mini_orm.FaissVectorStore","title":"<code>FaissVectorStore</code>","text":"<p>Vector store adapter for Facebook AI Similarity Search (Faiss).</p>"},{"location":"api/package/#mini_orm.InMemoryVectorStore","title":"<code>InMemoryVectorStore</code>","text":"<p>Simple in-memory implementation of vector database operations.</p>"},{"location":"api/package/#mini_orm.MySQLDialect","title":"<code>MySQLDialect</code>","text":"<p>               Bases: <code>Dialect</code></p> <p>MySQL dialect (<code>%s</code> positional parameters, no <code>RETURNING</code>).</p>"},{"location":"api/package/#mini_orm.MySQLDialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/package/#mini_orm.MySQLDialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/package/#mini_orm.MySQLDialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/package/#mini_orm.MySQLDialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/package/#mini_orm.PgVectorStore","title":"<code>PgVectorStore</code>","text":"<p>Vector store adapter backed by PostgreSQL + pgvector extension.</p>"},{"location":"api/package/#mini_orm.PoolConnector","title":"<code>PoolConnector</code>","text":"<p>Small fixed-size pool for DB-API connection objects.</p>"},{"location":"api/package/#mini_orm.PoolConnector.acquire","title":"<code>acquire(timeout=None)</code>","text":"<p>Borrow one connection from the pool.</p>"},{"location":"api/package/#mini_orm.PoolConnector.release","title":"<code>release(conn)</code>","text":"<p>Return one borrowed connection to the pool.</p>"},{"location":"api/package/#mini_orm.PoolConnector.connection","title":"<code>connection(timeout=None)</code>","text":"<p>Borrow and auto-release one connection with a context manager.</p>"},{"location":"api/package/#mini_orm.PoolConnector.close","title":"<code>close()</code>","text":"<p>Close all idle pooled connections and prevent future acquire.</p>"},{"location":"api/package/#mini_orm.PostgresDialect","title":"<code>PostgresDialect</code>","text":"<p>               Bases: <code>Dialect</code></p> <p>PostgreSQL dialect (<code>%s</code> positional parameters).</p>"},{"location":"api/package/#mini_orm.PostgresDialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/package/#mini_orm.PostgresDialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/package/#mini_orm.PostgresDialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/package/#mini_orm.PostgresDialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/package/#mini_orm.QdrantVectorStore","title":"<code>QdrantVectorStore</code>","text":"<p>Vector store adapter for Qdrant.</p>"},{"location":"api/package/#mini_orm.SQLiteDialect","title":"<code>SQLiteDialect</code>","text":"<p>               Bases: <code>Dialect</code></p> <p>SQLite dialect (<code>:name</code> parameters, supports <code>RETURNING</code>).</p>"},{"location":"api/package/#mini_orm.SQLiteDialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/package/#mini_orm.SQLiteDialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/package/#mini_orm.SQLiteDialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/package/#mini_orm.SQLiteDialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/package/#mini_orm.apply_schema","title":"<code>apply_schema(db, cls, *, if_not_exists=False)</code>","text":"<p>Create table and all configured indexes for a model on a database.</p>"},{"location":"api/package/#mini_orm.apply_schema_async","title":"<code>apply_schema_async(db, cls, *, if_not_exists=False)</code>  <code>async</code>","text":"<p>Async variant of <code>apply_schema</code> with identical SQL generation.</p>"},{"location":"api/package/#mini_orm.ensure_schema","title":"<code>ensure_schema(db, cls, *, schema_conflict='raise')</code>","text":"<p>Ensure schema exists and sync additive changes for a model.</p> <p>Behavior: - Create table/indexes if table does not exist. - If table exists:   - Keep unchanged schema as-is.   - Add missing columns when possible.   - Create missing indexes and recreate changed index definitions. - For incompatible column changes (type/nullability/PK changes), behavior   is controlled by <code>schema_conflict</code>:   - <code>\"raise\"</code>: raise <code>ValueError</code>.   - <code>\"recreate\"</code>: drop and recreate table/indexes.</p>"},{"location":"api/package/#mini_orm.ensure_schema_async","title":"<code>ensure_schema_async(db, cls, *, schema_conflict='raise')</code>  <code>async</code>","text":"<p>Async variant of <code>ensure_schema</code> with the same behavior.</p>"},{"location":"api/package/#mini_orm.create_index_sql","title":"<code>create_index_sql(cls, dialect, column, *, unique=False, name=None, if_not_exists=False)</code>","text":"<p>Build one single-column index SQL statement.</p>"},{"location":"api/package/#mini_orm.create_indexes_sql","title":"<code>create_indexes_sql(cls, dialect, *, if_not_exists=False)</code>","text":"<p>Build index SQL statements from model field metadata and <code>__indexes__</code>.</p>"},{"location":"api/package/#mini_orm.create_schema_sql","title":"<code>create_schema_sql(cls, dialect, *, if_not_exists=False)</code>","text":"<p>Build full schema SQL list (table first, then indexes).</p>"},{"location":"api/package/#mini_orm.create_table_sql","title":"<code>create_table_sql(cls, dialect, *, if_not_exists=False)</code>","text":"<p>Build <code>CREATE TABLE</code> statement for a dataclass model.</p>"},{"location":"api/package/#mini_orm.model_relations","title":"<code>model_relations(cls)</code>","text":"<p>Parse/derive model relations and validate relation specs.</p>"},{"location":"api/ports/","title":"Ports API","text":""},{"location":"api/ports/#mini_ormportsdb_apidialects","title":"<code>mini_orm.ports.db_api.dialects</code>","text":""},{"location":"api/ports/#mini_orm.ports.db_api.dialects","title":"<code>mini_orm.ports.db_api.dialects</code>","text":"<p>Concrete SQL dialect implementations for DB-API adapters.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.Dialect","title":"<code>Dialect</code>","text":"<p>Base dialect that defines SQL quoting and placeholder behavior.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.Dialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.Dialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.Dialect.auto_pk_sql","title":"<code>auto_pk_sql(pk_name)</code>","text":"<p>Return SQL fragment for auto-increment primary key column.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.Dialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.Dialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.SQLiteDialect","title":"<code>SQLiteDialect</code>","text":"<p>               Bases: <code>Dialect</code></p> <p>SQLite dialect (<code>:name</code> parameters, supports <code>RETURNING</code>).</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.SQLiteDialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.SQLiteDialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.SQLiteDialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.SQLiteDialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.PostgresDialect","title":"<code>PostgresDialect</code>","text":"<p>               Bases: <code>Dialect</code></p> <p>PostgreSQL dialect (<code>%s</code> positional parameters).</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.PostgresDialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.PostgresDialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.PostgresDialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.PostgresDialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.MySQLDialect","title":"<code>MySQLDialect</code>","text":"<p>               Bases: <code>Dialect</code></p> <p>MySQL dialect (<code>%s</code> positional parameters, no <code>RETURNING</code>).</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.MySQLDialect.q","title":"<code>q(ident)</code>","text":"<p>Quote SQL identifier.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.MySQLDialect.placeholder","title":"<code>placeholder(key)</code>","text":"<p>Return parameter placeholder for current param style.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.MySQLDialect.returning_clause","title":"<code>returning_clause(pk_name)</code>","text":"<p>Return <code>RETURNING</code> clause when dialect supports it.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.dialects.MySQLDialect.get_lastrowid","title":"<code>get_lastrowid(cursor)</code>","text":"<p>Extract <code>lastrowid</code> from DB-API cursor when available.</p>"},{"location":"api/ports/#mini_ormportsdb_apidatabase","title":"<code>mini_orm.ports.db_api.database</code>","text":""},{"location":"api/ports/#mini_orm.ports.db_api.database","title":"<code>mini_orm.ports.db_api.database</code>","text":"<p>DB-API adapter implementation for the core database port.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.database.Database","title":"<code>Database</code>","text":"<p>Thin DB-API wrapper that normalizes execute and row mapping behavior.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.database.Database.transaction","title":"<code>transaction()</code>","text":"<p>Provide commit/rollback transaction scope.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.database.Database.execute","title":"<code>execute(sql, params=None)</code>","text":"<p>Execute SQL with optional parameters and return cursor.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.database.Database.fetchone","title":"<code>fetchone(sql, params=None)</code>","text":"<p>Execute query and return one normalized row mapping.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.database.Database.fetchall","title":"<code>fetchall(sql, params=None)</code>","text":"<p>Execute query and return all rows as normalized mappings.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.database.Database.close","title":"<code>close(*, close_pool=False)</code>","text":"<p>Release/close underlying connection.</p> <p>Parameters:</p> Name Type Description Default <code>close_pool</code> <code>bool</code> <p>Also close pooled connector when this adapter uses <code>PoolConnector</code>.</p> <code>False</code>"},{"location":"api/ports/#mini_ormportsdb_apiasync_database","title":"<code>mini_orm.ports.db_api.async_database</code>","text":""},{"location":"api/ports/#mini_orm.ports.db_api.async_database","title":"<code>mini_orm.ports.db_api.async_database</code>","text":"<p>Async DB adapter implementation for the core async database port.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.async_database.AsyncDatabase","title":"<code>AsyncDatabase</code>","text":"<p>Async database wrapper that normalizes execute and row mapping behavior.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.async_database.AsyncDatabase.transaction","title":"<code>transaction()</code>  <code>async</code>","text":"<p>Provide async commit/rollback transaction scope.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.async_database.AsyncDatabase.execute","title":"<code>execute(sql, params=None)</code>  <code>async</code>","text":"<p>Execute SQL with optional parameters and return cursor.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.async_database.AsyncDatabase.fetchone","title":"<code>fetchone(sql, params=None)</code>  <code>async</code>","text":"<p>Execute query and return one normalized row mapping.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.async_database.AsyncDatabase.fetchall","title":"<code>fetchall(sql, params=None)</code>  <code>async</code>","text":"<p>Execute query and return all rows as normalized mappings.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.async_database.AsyncDatabase.close","title":"<code>close(*, close_pool=False)</code>","text":"<p>Release/close underlying connection.</p> <p>Parameters:</p> Name Type Description Default <code>close_pool</code> <code>bool</code> <p>Also close pooled connector when this adapter uses <code>PoolConnector</code>.</p> <code>False</code>"},{"location":"api/ports/#mini_orm.ports.db_api.async_database.AsyncDatabase.aclose","title":"<code>aclose(*, close_pool=False)</code>  <code>async</code>","text":"<p>Async release/close underlying connection.</p> <p>Parameters:</p> Name Type Description Default <code>close_pool</code> <code>bool</code> <p>Also close pooled connector when this adapter uses <code>PoolConnector</code>.</p> <code>False</code>"},{"location":"api/ports/#mini_ormportsdb_apipool_connector","title":"<code>mini_orm.ports.db_api.pool_connector</code>","text":""},{"location":"api/ports/#mini_orm.ports.db_api.pool_connector","title":"<code>mini_orm.ports.db_api.pool_connector</code>","text":"<p>Simple thread-safe DB-API connection pool.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.pool_connector.PoolConnector","title":"<code>PoolConnector</code>","text":"<p>Small fixed-size pool for DB-API connection objects.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.pool_connector.PoolConnector.acquire","title":"<code>acquire(timeout=None)</code>","text":"<p>Borrow one connection from the pool.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.pool_connector.PoolConnector.release","title":"<code>release(conn)</code>","text":"<p>Return one borrowed connection to the pool.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.pool_connector.PoolConnector.connection","title":"<code>connection(timeout=None)</code>","text":"<p>Borrow and auto-release one connection with a context manager.</p>"},{"location":"api/ports/#mini_orm.ports.db_api.pool_connector.PoolConnector.close","title":"<code>close()</code>","text":"<p>Close all idle pooled connections and prevent future acquire.</p>"},{"location":"api/ports/#mini_ormportsvectorin_memory","title":"<code>mini_orm.ports.vector.in_memory</code>","text":""},{"location":"api/ports/#mini_orm.ports.vector.in_memory","title":"<code>mini_orm.ports.vector.in_memory</code>","text":"<p>In-memory vector store adapter for testing and local development.</p>"},{"location":"api/ports/#mini_orm.ports.vector.in_memory.InMemoryVectorStore","title":"<code>InMemoryVectorStore</code>","text":"<p>Simple in-memory implementation of vector database operations.</p>"},{"location":"api/ports/#mini_ormportsvectorpgvector","title":"<code>mini_orm.ports.vector.pgvector</code>","text":""},{"location":"api/ports/#mini_orm.ports.vector.pgvector","title":"<code>mini_orm.ports.vector.pgvector</code>","text":"<p>PostgreSQL pgvector adapter implementing vector store operations.</p> <p>This adapter uses a regular Mini ORM <code>Database</code> configured with <code>PostgresDialect</code>, so SQL CRUD and vector search can share the same PostgreSQL connection/pool.</p>"},{"location":"api/ports/#mini_orm.ports.vector.pgvector.PgVectorStore","title":"<code>PgVectorStore</code>","text":"<p>Vector store adapter backed by PostgreSQL + pgvector extension.</p>"},{"location":"api/ports/#mini_ormportsvectorqdrant","title":"<code>mini_orm.ports.vector.qdrant</code>","text":""},{"location":"api/ports/#mini_orm.ports.vector.qdrant","title":"<code>mini_orm.ports.vector.qdrant</code>","text":"<p>Qdrant adapter implementing vector store operations.</p> <p>This adapter is optional and requires <code>qdrant-client</code> package installed.</p>"},{"location":"api/ports/#mini_orm.ports.vector.qdrant.QdrantVectorStore","title":"<code>QdrantVectorStore</code>","text":"<p>Vector store adapter for Qdrant.</p>"},{"location":"api/ports/#mini_ormportsvectorchroma","title":"<code>mini_orm.ports.vector.chroma</code>","text":""},{"location":"api/ports/#mini_orm.ports.vector.chroma","title":"<code>mini_orm.ports.vector.chroma</code>","text":"<p>Chroma adapter implementing vector store operations.</p> <p>This adapter is optional and requires <code>chromadb</code> package installed.</p>"},{"location":"api/ports/#mini_orm.ports.vector.chroma.ChromaVectorStore","title":"<code>ChromaVectorStore</code>","text":"<p>Vector store adapter for ChromaDB.</p>"},{"location":"api/ports/#mini_ormportsvectorfaiss","title":"<code>mini_orm.ports.vector.faiss</code>","text":""},{"location":"api/ports/#mini_orm.ports.vector.faiss","title":"<code>mini_orm.ports.vector.faiss</code>","text":"<p>Faiss adapter implementing vector store operations.</p> <p>This adapter is optional and requires <code>faiss-cpu</code> and <code>numpy</code> packages installed.</p>"},{"location":"api/ports/#mini_orm.ports.vector.faiss.FaissVectorStore","title":"<code>FaissVectorStore</code>","text":"<p>Vector store adapter for Facebook AI Similarity Search (Faiss).</p>"},{"location":"sql/overview/","title":"SQL ORM Overview","text":""},{"location":"sql/overview/#core-flow","title":"Core flow","text":"<ol> <li>Define a dataclass model.</li> <li>Create a <code>Database</code> adapter with a SQL dialect.</li> <li>Apply schema (<code>apply_schema</code>).</li> <li>Use <code>Repository[T]</code> for single-model access, or <code>UnifiedRepository</code> when one    hub object should route by model class.    Mutation methods can infer model from object (<code>hub.insert(User(...))</code>).    Optionally set <code>auto_schema=True</code> to create/sync schema automatically on first action    (or when calling <code>register(...)</code>).    Set <code>require_registration=True</code> if you want explicit model registration before actions.</li> </ol>"},{"location":"sql/overview/#async-flow-same-method-names","title":"Async flow (same method names)","text":"<ol> <li>Define a dataclass model.</li> <li>Create an <code>AsyncDatabase</code> adapter with a SQL dialect.</li> <li>Apply schema (<code>await apply_schema_async(...)</code>).</li> <li>Use <code>AsyncRepository[T]</code> for single-model access, or <code>AsyncUnifiedRepository</code>    for one async hub object routing by model class, with the same method names as sync    (<code>insert</code>, <code>get</code>, <code>list</code>, <code>update</code>, <code>delete</code>, ...), but with <code>await</code>.    Async unified mutation methods can infer model from object as well.    Optionally set <code>auto_schema=True</code> for automatic schema ensure on first action    (or when calling <code>register(...)</code>).    Set <code>require_registration=True</code> for explicit registration workflow.</li> </ol>"},{"location":"sql/overview/#unified-hub-multi-model","title":"Unified hub (multi-model)","text":"<pre><code>import asyncio\n\nfrom mini_orm import UnifiedRepository, AsyncUnifiedRepository\n\n# sync\nhub = UnifiedRepository(db, auto_schema=True, require_registration=True)\nhub.register(User)\nuser = hub.insert(User(email=\"alice@example.com\"))  # infer model from object\nrows = hub.list(User)\n\n# async\nasync def main() -&gt; None:\n    async_hub = AsyncUnifiedRepository(\n        async_db,\n        auto_schema=True,\n        require_registration=True,\n    )\n    await async_hub.register(User)\n    user = await async_hub.insert(User(email=\"alice@example.com\"))\n    rows = await async_hub.list(User)\n    print(user, rows)\n\nasyncio.run(main())\n</code></pre> <p><code>schema_conflict</code> controls incompatible changes: - <code>\"raise\"</code> (default): raise clear error. - <code>\"recreate\"</code>: drop/recreate table for that model.</p>"},{"location":"sql/overview/#args-quick-reference","title":"Args quick reference","text":"<p>Repository constructors (<code>Repository</code>, <code>AsyncRepository</code>):</p> <ul> <li><code>auto_schema: bool = False</code></li> <li><code>True</code>: ensure schema automatically on first action.</li> <li><code>False</code>: do not auto-ensure schema.</li> <li><code>schema_conflict: str = \"raise\"</code></li> <li><code>\"raise\"</code>: incompatible schema -&gt; error.</li> <li><code>\"recreate\"</code>: incompatible schema -&gt; drop/recreate table.</li> <li><code>require_registration: bool = False</code></li> <li><code>True</code>: require explicit <code>register(...)</code> before actions.</li> <li><code>False</code>: model auto-registers on first action.</li> </ul> <p>Unified constructors (<code>UnifiedRepository</code>, <code>AsyncUnifiedRepository</code>) use the same args.</p> <p>Registration helpers:</p> <ul> <li><code>Repository[T].register(ensure=None)</code> / <code>await AsyncRepository[T].register(ensure=None)</code></li> <li>no model arg (model is bound in repository constructor).</li> <li><code>ensure=None</code>: follow <code>auto_schema</code>.</li> <li><code>ensure=True</code>: ensure schema immediately, then register.</li> <li><code>ensure=False</code>: only register.</li> <li><code>Repository[T].register_many(ensure=None)</code> / async equivalent:</li> <li>single-model alias for API consistency, same ensure behavior.</li> <li><code>UnifiedRepository.register(model, ensure=None)</code> / async equivalent:</li> <li>requires explicit model arg because unified hub manages many models.</li> <li><code>ensure=None</code>: follow <code>auto_schema</code>.</li> <li><code>ensure=True</code>: ensure schema immediately, then register that model.</li> <li><code>ensure=False</code>: only register.</li> <li><code>UnifiedRepository.register_many(models, ensure=None)</code> / async equivalent: batch version.</li> </ul> <p>Unified mutation calls support:</p> <ul> <li>explicit model: <code>hub.insert(User, user_obj)</code>.</li> <li>inferred model: <code>hub.insert(user_obj)</code>.</li> </ul> <p>Inference also applies to: <code>update</code>, <code>delete</code>, <code>create</code>, <code>insert_many</code>.</p>"},{"location":"sql/overview/#relations-via-metadata","title":"Relations via metadata","text":"<p><code>Repository</code> relation APIs support <code>belongs_to</code> and <code>has_many</code>. Relation specs can be inferred directly from FK field metadata:</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import Optional\n\n@dataclass\nclass Author:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    name: str = \"\"\n\n@dataclass\nclass Post:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    author_id: Optional[int] = field(\n        default=None,\n        metadata={\n            \"fk\": (Author, \"id\"),\n            \"relation\": \"author\",      # optional belongs_to name\n            \"related_name\": \"posts\",   # optional reverse has_many name\n        },\n    )\n</code></pre> <p>Inference result: - child side: <code>Post.author</code> (<code>belongs_to</code>) - parent side: <code>Author.posts</code> (<code>has_many</code>)</p> <p>Use with: - <code>repo.create(..., relations=...)</code> - <code>repo.get_related(pk, include=[...])</code> - <code>repo.list_related(include=[...])</code></p> <p>The same relation APIs are available in async form: - <code>await repo.create(..., relations=...)</code> - <code>await repo.get_related(pk, include=[...])</code> - <code>await repo.list_related(include=[...])</code></p> <p>Default names when omitted: - <code>author_id</code> -&gt; <code>author</code> - child model <code>Post</code> -&gt; <code>posts</code></p> <p>Explicit <code>__relations__</code> is still supported when you need full manual control. For end-to-end examples and error cases, see <code>docs/sql/repository.md</code>.</p> <p>Common repository helpers:</p> <ul> <li><code>count(where=...)</code>, <code>exists(where=...)</code></li> <li><code>insert_many(...)</code></li> <li><code>update_where(values, where=...)</code>, <code>delete_where(where=...)</code></li> <li><code>get_or_create(lookup=..., defaults=...)</code></li> </ul> <p>Async repository provides the same helper names with <code>await</code>.</p>"},{"location":"sql/overview/#field-codec-flow-enumjson","title":"Field codec flow (Enum/JSON)","text":"<p>Repository I/O supports automatic value conversion:</p> <ul> <li>Enum fields are stored using <code>Enum.value</code> and reconstructed as Enum on read.</li> <li><code>dict</code>/<code>list</code> fields are stored as JSON text and reconstructed on read.</li> <li>You can force JSON handling with <code>metadata={\"codec\": \"json\"}</code>.</li> </ul> <p>See runnable example: - <code>examples/sql/08_codec_serialize_deserialize.py</code></p>"},{"location":"sql/overview/#layer-boundaries","title":"Layer boundaries","text":"<ul> <li><code>mini_orm.core</code></li> <li>Conditions, query builder, metadata, repository, async repository, schema.</li> <li><code>mini_orm.ports.db_api</code></li> <li><code>Database</code> / <code>AsyncDatabase</code> adapters and dialect implementations.</li> <li><code>PoolConnector</code> for connection pooling with safety guards:<ul> <li>SQLite private in-memory detection for <code>max_size &gt; 1</code>.</li> <li>SQLite <code>check_same_thread</code> guard for pooled connections.</li> <li>Dirty transaction guard on release (<code>rollback</code> / <code>raise</code> / <code>ignore</code> / <code>discard</code>).</li> <li>Optional strict mode to discard dirty connections.</li> </ul> </li> </ul> <p>This separation keeps SQL generation logic backend-agnostic and lets you replace adapters without changing core behavior.</p>"},{"location":"sql/overview/#dialects","title":"Dialects","text":"<p>Built-in dialects:</p> <ul> <li><code>SQLiteDialect</code></li> <li><code>PostgresDialect</code></li> <li><code>MySQLDialect</code></li> </ul> <p>Dialect controls:</p> <ul> <li>Identifier quoting</li> <li>Placeholder style (<code>:name</code>, <code>%s</code>, <code>?</code>)</li> <li><code>RETURNING</code> support</li> </ul>"},{"location":"sql/repository/","title":"Repository Queries","text":"<p><code>Repository[T]</code> provides single-table CRUD with optional filtering and pagination. <code>AsyncRepository[T]</code> provides the same API surface with <code>await</code>. <code>UnifiedRepository</code> / <code>AsyncUnifiedRepository</code> route the same APIs by model class when you prefer one hub object for multiple tables. For mutation methods (<code>insert</code>/<code>update</code>/<code>delete</code>/<code>create</code>/<code>insert_many</code>), model can be inferred from object input.</p> <p>Schema convenience options: - <code>auto_schema=True</code>: automatically create/sync schema on first action (or when calling <code>register(...)</code>). - <code>schema_conflict=\"raise\" | \"recreate\"</code>: behavior for incompatible column changes. - <code>require_registration=True</code>: require <code>register()</code> / <code>register_many(...)</code> before actions. - <code>register(..., ensure=False)</code> registers the model without schema ensure; because the model is already registered, first action also skips automatic schema ensure (even when <code>auto_schema=True</code>).</p>"},{"location":"sql/repository/#constructor-args","title":"Constructor args","text":"<p><code>Repository(db, model, *, auto_schema=False, schema_conflict=\"raise\", require_registration=False)</code></p> <p><code>AsyncRepository(db, model, *, auto_schema=False, schema_conflict=\"raise\", require_registration=False)</code></p> <ul> <li><code>db</code>: DB adapter instance.</li> <li><code>model</code>: dataclass model class this repository manages.</li> <li><code>auto_schema</code>:</li> <li><code>False</code> (default): no automatic schema work.</li> <li><code>True</code>: ensure schema on first action (or during <code>register(..., ensure=True)</code>).</li> <li><code>schema_conflict</code>:</li> <li><code>\"raise\"</code> (default): stop with clear error when schema is incompatible.</li> <li><code>\"recreate\"</code>: drop and recreate table on incompatible changes.</li> <li><code>require_registration</code>:</li> <li><code>False</code> (default): model auto-registers on first action.</li> <li><code>True</code>: must call <code>register(...)</code> first, otherwise CRUD raises.</li> </ul> <p><code>UnifiedRepository</code> / <code>AsyncUnifiedRepository</code> use the same flags.</p>"},{"location":"sql/repository/#register-args","title":"Register args","text":"<ul> <li><code>Repository[T].register(ensure=None)</code> / <code>await AsyncRepository[T].register(ensure=None)</code></li> <li><code>ensure=None</code> (default): follow <code>auto_schema</code>.</li> <li><code>ensure=True</code>: force ensure schema now, then register.</li> <li><code>ensure=False</code>: register only.</li> <li><code>Repository[T].register_many(ensure=None)</code> / async equivalent:</li> <li>single-model alias with the same ensure behavior.</li> <li><code>UnifiedRepository.register(model, ensure=None)</code> / <code>await AsyncUnifiedRepository.register(model, ensure=None)</code></li> <li><code>ensure=None</code> (default): follow <code>auto_schema</code>.</li> <li><code>ensure=True</code>: force ensure schema now, then register that model.</li> <li><code>ensure=False</code>: register only.</li> <li><code>UnifiedRepository.register_many(models, ensure=None)</code> / async equivalent:</li> <li>apply the same ensure behavior per model in the list.</li> </ul>"},{"location":"sql/repository/#unified-mutation-args","title":"Unified mutation args","text":"<p>For these methods: <code>insert</code>, <code>update</code>, <code>delete</code>, <code>create</code>, <code>insert_many</code>.</p> <p>You can call in 2 ways:</p> <ul> <li>Explicit model:</li> <li><code>hub.insert(User, user_obj)</code></li> <li><code>hub.insert_many(User, [u1, u2])</code></li> <li>Inferred model from object:</li> <li><code>hub.insert(user_obj)</code></li> <li><code>hub.insert_many([u1, u2])</code></li> </ul> <p>Read/query methods remain model-class-first: - <code>get(User, id)</code>, <code>list(User, ...)</code>, <code>count(User, ...)</code>, <code>exists(User, ...)</code>, ...</p>"},{"location":"sql/repository/#async-equivalent-same-method-names","title":"Async equivalent (same method names)","text":"<pre><code>import asyncio\n\nfrom mini_orm import C\n\n\nasync def main() -&gt; None:\n    await repo.insert(User(email=\"a@example.com\", age=20))\n\n    user = (await repo.list(where=C.eq(\"email\", \"a@example.com\")))[0]\n    user.age = 21\n    await repo.update(user)\n\n    await repo.delete(user)\n\n\nasyncio.run(main())\n</code></pre> <p><code>AsyncRepository</code> keeps sync method names: - <code>insert</code>, <code>update</code>, <code>delete</code>, <code>get</code>, <code>list</code> - <code>count</code>, <code>exists</code>, <code>insert_many</code> - <code>update_where</code>, <code>delete_where</code>, <code>get_or_create</code> - <code>create</code>, <code>get_related</code>, <code>list_related</code></p>"},{"location":"sql/repository/#insert-update-delete","title":"Insert / update / delete","text":"<pre><code>repo.insert(User(email=\"a@example.com\", age=20))\n\nuser = repo.list(where=C.eq(\"email\", \"a@example.com\"))[0]\nuser.age = 21\nrepo.update(user)\n\nrepo.delete(user)\n</code></pre>"},{"location":"sql/repository/#filter-and-order","title":"Filter and order","text":"<pre><code>from mini_orm import C, OrderBy\n\nrows = repo.list(\n    where=[C.ge(\"age\", 18), C.lt(\"age\", 30)],\n    order_by=[OrderBy(\"age\", desc=True), OrderBy(\"id\", desc=False)],\n    limit=20,\n    offset=0,\n)\n</code></pre> <p><code>where</code> accepts one condition or a list of conditions joined by <code>AND</code>.</p>"},{"location":"sql/repository/#grouped-conditions-and-or-not","title":"Grouped conditions (<code>AND</code> / <code>OR</code> / <code>NOT</code>)","text":"<pre><code>rows = repo.list(\n    where=C.and_(\n        C.eq(\"active\", True),\n        C.or_(C.eq(\"role\", \"admin\"), C.eq(\"role\", \"owner\")),\n        C.not_(C.eq(\"email\", \"blocked@example.com\")),\n    )\n)\n</code></pre>"},{"location":"sql/repository/#utility-methods","title":"Utility methods","text":"<pre><code>total = repo.count(where=C.like(\"email\", \"%@example.com\"))\nhas_adult = repo.exists(where=C.ge(\"age\", 18))\n\nrepo.insert_many([User(email=\"u1@example.com\"), User(email=\"u2@example.com\")])\n\nrepo.update_where({\"age\": 30}, where=C.eq(\"email\", \"u1@example.com\"))\nrepo.delete_where(where=C.eq(\"email\", \"u2@example.com\"))\n\nrow, created = repo.get_or_create(\n    lookup={\"email\": \"first@example.com\"},\n    defaults={\"age\": 20},\n)\n</code></pre>"},{"location":"sql/repository/#unified-repository-hub-multi-model","title":"Unified repository hub (multi-model)","text":"<pre><code>from mini_orm import UnifiedRepository\n\nhub = UnifiedRepository(db, auto_schema=True, require_registration=True)\nhub.register(User)\nhub.insert(User(email=\"u1@example.com\"))  # infer model from object\nusers = hub.list(User)\n</code></pre> <p>Async:</p> <pre><code>import asyncio\n\nfrom mini_orm import AsyncUnifiedRepository\n\nasync def main() -&gt; None:\n    hub = AsyncUnifiedRepository(async_db, auto_schema=True, require_registration=True)\n    await hub.register(User)\n    await hub.insert(User(email=\"u1@example.com\"))\n    users = await hub.list(User)\n    print(users)\n\nasyncio.run(main())\n</code></pre>"},{"location":"sql/repository/#field-codecs-enumjson","title":"Field codecs (Enum/JSON)","text":"<p><code>Repository</code> serializes/deserializes supported field types on both input and output:</p> <ul> <li>Enum field: stored as <code>Enum.value</code>, read back as Enum.</li> <li><code>dict</code>/<code>list</code> field: stored as JSON text, read back as Python structure.</li> <li>Explicit codec: <code>metadata={\"codec\": \"json\"}</code>.</li> </ul> <pre><code>from dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Optional\n\nclass Status(str, Enum):\n    DRAFT = \"draft\"\n    PUBLISHED = \"published\"\n\n@dataclass\nclass Article:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    status: Status = Status.DRAFT\n    payload: dict[str, Any] = field(default_factory=dict)\n    tags: list[str] = field(default_factory=list)\n    extra: Any = field(default_factory=dict, metadata={\"codec\": \"json\"})\n\nrepo.insert(Article(status=Status.PUBLISHED, payload={\"views\": 1}, tags=[\"orm\"]))\nrows = repo.list(where=C.eq(\"status\", Status.PUBLISHED))\n</code></pre>"},{"location":"sql/repository/#get-by-primary-key","title":"Get by primary key","text":"<pre><code>row = repo.get(1)\n</code></pre> <p>Async:</p> <pre><code>import asyncio\n\n\nasync def main() -&gt; None:\n    row = await repo.get(1)\n    print(row)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"sql/repository/#relations-create-and-query","title":"Relations (create and query)","text":"<p>Declare relation intent on FK metadata and let mini_orm infer relation specs.</p>"},{"location":"sql/repository/#1-minimal-declaration","title":"1) Minimal declaration","text":"<pre><code>@dataclass\nclass Author:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    name: str = \"\"\n\n@dataclass\nclass Post:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    author_id: Optional[int] = field(\n        default=None,\n        metadata={\"fk\": (Author, \"id\")},\n    )\n    title: str = \"\"\n</code></pre> <p>From one FK field, mini_orm infers both sides: - <code>Post.author</code> (<code>belongs_to</code>) - <code>Author.posts</code> (<code>has_many</code>)</p>"},{"location":"sql/repository/#2-optional-relation-naming","title":"2) Optional relation naming","text":"<p>Use metadata keys to control relation names explicitly:</p> <pre><code>@dataclass\nclass Author:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    name: str = \"\"\n\n@dataclass\nclass Post:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    author_id: Optional[int] = field(\n        default=None,\n        metadata={\n            \"fk\": (Author, \"id\"),\n            \"relation\": \"author\",      # name for belongs_to on Post\n            \"related_name\": \"posts\",   # reverse has_many name on Author\n        },\n    )\n    title: str = \"\"\n</code></pre>"},{"location":"sql/repository/#3-default-naming-rules","title":"3) Default naming rules","text":"<p>If you omit explicit names: - <code>relation</code> defaults from FK field name:     <code>author_id</code> -&gt; <code>author</code> - <code>related_name</code> defaults from child model name pluralization:     <code>Post</code> -&gt; <code>posts</code></p> <p>For irregular names or multiple FKs to the same target model, set <code>relation</code>/<code>related_name</code> explicitly to avoid ambiguity.</p>"},{"location":"sql/repository/#4-create-with-nested-relations","title":"4) Create with nested relations","text":"<p><code>Repository.create(..., relations=...)</code> supports both directions:</p> <pre><code># has_many path (create parent + children)\nauthor_repo.create(\n    Author(name=\"alice\"),\n    relations={\"posts\": [Post(title=\"p1\"), Post(title=\"p2\")]},\n)\n\n# belongs_to path (create child + nested parent)\npost_repo.create(\n    Post(title=\"hello\"),\n    relations={\"author\": Author(name=\"bob\")},\n)\n</code></pre>"},{"location":"sql/repository/#5-query-with-included-relations","title":"5) Query with included relations","text":"<p>Use <code>include=[...]</code> with <code>get_related</code>/<code>list_related</code>:</p> <pre><code>author_with_posts = author_repo.get_related(1, include=[\"posts\"])\nposts_with_author = post_repo.list_related(include=[\"author\"])\n</code></pre> <p>Async:</p> <pre><code>import asyncio\n\n\nasync def main() -&gt; None:\n    author_with_posts = await author_repo.get_related(1, include=[\"posts\"])\n    posts_with_author = await post_repo.list_related(include=[\"author\"])\n    print(author_with_posts, posts_with_author)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"sql/repository/#6-metadata-formats-supported-for-relation-inference","title":"6) Metadata formats supported for relation inference","text":"<p>Relation inference needs an FK that references a model class: - <code>metadata={\"fk\": (Author, \"id\")}</code> - <code>metadata={\"fk\": {\"model\": Author, \"column\": \"id\"}}</code></p> <p><code>fk</code> string format (<code>\"author.id\"</code>) is valid for SQL schema generation, but it does not carry the model class, so relation inference cannot build <code>include</code> relations from it.</p>"},{"location":"sql/repository/#7-explicit-relation-override","title":"7) Explicit relation override","text":"<p>You can still define <code>__relations__</code> for full manual control. Explicit declarations are kept and inferred duplicates are skipped. This is also the recommended path when parent/child models are split across different modules and you need guaranteed reverse <code>has_many</code> discovery.</p>"},{"location":"sql/repository/#8-common-validation-errors","title":"8) Common validation errors","text":"<ul> <li><code>Unknown relation '...'</code> when calling <code>include</code>/<code>relations</code>:   relation name is not inferred or declared.</li> <li><code>expects a sequence</code> on has_many create:   pass a list/tuple of model objects.</li> <li><code>expects &lt;ModelName&gt;</code>:   nested relation value type does not match the target model.</li> <li>duplicate inferred relation names:   set <code>relation</code> and/or <code>related_name</code> to disambiguate.</li> </ul>"},{"location":"sql/schema-indexing/","title":"Schema and Indexing","text":"<p><code>mini_orm</code> can generate table and index SQL directly from dataclass definitions.</p>"},{"location":"sql/schema-indexing/#field-level-index","title":"Field-level index","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Optional\n\n@dataclass\nclass User:\n    id: Optional[int] = field(default=None, metadata={\"pk\": True, \"auto\": True})\n    email: str = field(default=\"\", metadata={\"index\": True})\n    username: str = field(default=\"\", metadata={\"unique_index\": True})\n</code></pre> <p>Supported metadata keys:</p> <ul> <li><code>pk=True</code>: primary key</li> <li><code>auto=True</code>: auto-increment PK behavior</li> <li><code>index=True</code>: normal index</li> <li><code>unique_index=True</code>: unique index</li> <li><code>index_name=\"...\"</code>: custom single-column index name</li> <li><code>codec=\"json\"</code> / <code>codec=\"enum\"</code>: explicit repository I/O codec override for field values</li> <li><code>fk=...</code>: foreign key reference (<code>\"table.column\"</code>, <code>(ModelOrTable, \"column\")</code>, or <code>{\"model\": Model, \"column\": \"id\"}</code>)</li> </ul> <p>Note for relation APIs (<code>create(..., relations=...)</code>, <code>get_related</code>, <code>list_related</code>): - schema generation accepts all FK formats above - relation inference needs a model-aware FK (<code>(Model, \"column\")</code> or   <code>{\"model\": Model, \"column\": \"...\"}</code>), because <code>\"table.column\"</code> does not include   a Python model class to link.</p>"},{"location":"sql/schema-indexing/#mysql-limitation-for-string-indexes","title":"MySQL limitation for string indexes","text":"<p>With <code>MySQLDialect</code>, Python <code>str</code> currently maps to SQL <code>TEXT</code>. MySQL requires a key length when indexing <code>TEXT</code>, so <code>index=True</code> or <code>unique_index=True</code> on <code>str</code> fields can fail during <code>apply_schema(...)</code> with:</p> <p><code>BLOB/TEXT column '...' used in key specification without a key length</code></p> <p>Recommended workaround:</p> <ul> <li>avoid <code>index</code>/<code>unique_index</code> on <code>str</code> fields when using MySQL, or</li> <li>use custom schema/type mapping so indexed string columns become <code>VARCHAR(n)</code>.</li> </ul>"},{"location":"sql/schema-indexing/#multi-column-index","title":"Multi-column index","text":"<pre><code>@dataclass\nclass User:\n    ...\n    __indexes__ = [\n        (\"email\", \"username\"),\n        {\"columns\": (\"email\", \"age\"), \"unique\": False, \"name\": \"idx_user_email_age\"},\n    ]\n</code></pre>"},{"location":"sql/schema-indexing/#apply-table-indexes-in-one-call","title":"Apply table + indexes in one call","text":"<pre><code>import asyncio\n\nfrom mini_orm import apply_schema, apply_schema_async\n\napply_schema(db, User)\n# idempotent mode (safe to run repeatedly):\napply_schema(db, User, if_not_exists=True)\n\n# async equivalent:\nasync def main() -&gt; None:\n    await apply_schema_async(async_db, User)\n    await apply_schema_async(async_db, User, if_not_exists=True)\n\n\nasyncio.run(main())\n</code></pre> <p><code>apply_schema</code> executes table creation first, then all configured indexes in the same transaction. <code>apply_schema_async</code> uses the same SQL generation and behavior in async flow.</p>"},{"location":"sql/schema-indexing/#manual-sql-generation","title":"Manual SQL generation","text":"<pre><code>from mini_orm import create_table_sql, create_indexes_sql\n\ntable_sql = create_table_sql(User, db.dialect)\nindex_sql_list = create_indexes_sql(User, db.dialect)\n\n# generate CREATE ... IF NOT EXISTS (supported by sqlite/postgres for indexes)\ntable_sql_safe = create_table_sql(User, db.dialect, if_not_exists=True)\nindex_sql_safe = create_indexes_sql(User, db.dialect, if_not_exists=True)\n</code></pre>"},{"location":"vector/chroma/","title":"Chroma Adapter","text":"<p><code>ChromaVectorStore</code> is an optional adapter for Chroma.</p>"},{"location":"vector/chroma/#install","title":"Install","text":"<pre><code>pip install chromadb\n</code></pre>"},{"location":"vector/chroma/#usage","title":"Usage","text":"<pre><code>from mini_orm import ChromaVectorStore, VectorRecord, VectorRepository\n\nstore = ChromaVectorStore(path=\"./.chroma\")\nrepo = VectorRepository(store, \"items\", dimension=4, metric=\"cosine\")\n\nrepo.upsert(\n    [\n        VectorRecord(id=\"1\", vector=[0.1, 0.2, 0.3, 0.4], payload={\"type\": \"doc\"}),\n    ]\n)\n\ntop = repo.query([0.1, 0.2, 0.25, 0.4], top_k=5)\n</code></pre>"},{"location":"vector/chroma/#notes","title":"Notes","text":"<ul> <li>Supported metrics: <code>cosine</code>, <code>dot</code>, <code>l2</code>.</li> <li><code>filters</code> are translated to Chroma <code>where</code> exact-match conditions.</li> </ul>"},{"location":"vector/faiss/","title":"Faiss Adapter","text":"<p><code>FaissVectorStore</code> is an optional adapter for Faiss.</p>"},{"location":"vector/faiss/#install","title":"Install","text":"<pre><code>pip install faiss-cpu numpy\n</code></pre>"},{"location":"vector/faiss/#usage","title":"Usage","text":"<pre><code>from mini_orm import FaissVectorStore, VectorRecord, VectorRepository\n\nstore = FaissVectorStore()\nrepo = VectorRepository(store, \"items\", dimension=4, metric=\"cosine\")\n\nrepo.upsert(\n    [\n        VectorRecord(id=\"1\", vector=[0.1, 0.2, 0.3, 0.4], payload={\"type\": \"doc\"}),\n    ]\n)\n\ntop = repo.query([0.1, 0.2, 0.25, 0.4], top_k=5)\n</code></pre>"},{"location":"vector/faiss/#notes","title":"Notes","text":"<ul> <li>Supported metrics: <code>cosine</code>, <code>dot</code>, <code>l2</code>.</li> <li><code>filters</code> are not supported and will raise <code>NotImplementedError</code>.</li> </ul>"},{"location":"vector/overview/","title":"Vector Overview","text":"<p>Vector features are exposed through:</p> <ul> <li><code>VectorRepository</code> in core.</li> <li><code>AsyncVectorRepository</code> in core.</li> <li>Vector store adapters in <code>mini_orm.ports.vector</code>.</li> </ul> <p>Optional backends included in this project:</p> <ul> <li><code>PgVectorStore</code> (PostgreSQL + pgvector extension)</li> <li><code>QdrantVectorStore</code></li> <li><code>ChromaVectorStore</code></li> <li><code>FaissVectorStore</code></li> </ul>"},{"location":"vector/overview/#in-memory-adapter-default-for-local-tests","title":"In-memory adapter (default for local tests)","text":"<pre><code>from mini_orm import InMemoryVectorStore, VectorRecord, VectorRepository\n\nstore = InMemoryVectorStore()\nrepo = VectorRepository(store, \"users\", dimension=3, metric=\"cosine\")\n\nrepo.upsert(\n    [\n        VectorRecord(id=\"u1\", vector=[0.1, 0.2, 0.3], payload={\"name\": \"alice\"}),\n        VectorRecord(id=\"u2\", vector=[0.2, 0.1, 0.5], payload={\"name\": \"bob\"}),\n    ]\n)\n\nresults = repo.query([0.1, 0.2, 0.25], top_k=2)\n</code></pre>"},{"location":"vector/overview/#async-usage-same-method-names","title":"Async usage (same method names)","text":"<pre><code>import asyncio\n\nfrom mini_orm import AsyncVectorRepository, InMemoryVectorStore, VectorRecord\n\nasync def main() -&gt; None:\n    store = InMemoryVectorStore()\n    repo = AsyncVectorRepository(store, \"users\", dimension=3, metric=\"cosine\")\n\n    await repo.upsert(\n        [\n            VectorRecord(id=\"u1\", vector=[0.1, 0.2, 0.3], payload={\"name\": \"alice\"}),\n            VectorRecord(id=\"u2\", vector=[0.2, 0.1, 0.5], payload={\"name\": \"bob\"}),\n        ]\n    )\n\n    results = await repo.query([0.1, 0.2, 0.25], top_k=2)\n    print(results)\n\nasyncio.run(main())\n</code></pre> <p><code>AsyncVectorRepository</code> keeps sync method names: - <code>create_collection</code>, <code>upsert</code>, <code>query</code>, <code>fetch</code>, <code>delete</code></p>"},{"location":"vector/overview/#payload-codec-optional","title":"Payload codec (optional)","text":"<p>Use a payload codec when metadata contains rich types (for example Enum, nested JSON):</p> <pre><code>from enum import Enum\nfrom mini_orm import (\n    InMemoryVectorStore,\n    JsonVectorPayloadCodec,\n    VectorRecord,\n    VectorRepository,\n)\n\nclass Status(str, Enum):\n    ACTIVE = \"active\"\n\nstore = InMemoryVectorStore()\nrepo = VectorRepository(\n    store,\n    \"users\",\n    dimension=2,\n    payload_codec=JsonVectorPayloadCodec(),\n)\nrepo.upsert([VectorRecord(id=\"u1\", vector=[1, 0], payload={\"status\": Status.ACTIVE})])\nhits = repo.query([1, 0], filters={\"status\": Status.ACTIVE})\n</code></pre> <p>Async equivalent:</p> <pre><code>import asyncio\nfrom enum import Enum\n\nfrom mini_orm import AsyncVectorRepository, InMemoryVectorStore, JsonVectorPayloadCodec, VectorRecord\n\nclass Status(str, Enum):\n    ACTIVE = \"active\"\n\nasync def main() -&gt; None:\n    store = InMemoryVectorStore()\n    repo = AsyncVectorRepository(\n        store,\n        \"users\",\n        dimension=2,\n        payload_codec=JsonVectorPayloadCodec(),\n    )\n    await repo.upsert(\n        [VectorRecord(id=\"u1\", vector=[1, 0], payload={\"status\": Status.ACTIVE})]\n    )\n    hits = await repo.query([1, 0], filters={\"status\": Status.ACTIVE})\n    print(hits)\n\nasyncio.run(main())\n</code></pre> <p>Notes: - Enum decode is best-effort: if enum class cannot be resolved at runtime,   decoded value falls back to scalar (for example <code>\"active\"</code>).</p> <p>Supported in-memory metrics:</p> <ul> <li><code>cosine</code></li> <li><code>dot</code></li> <li><code>l2</code> (stored as negative distance score for ranking)</li> </ul>"},{"location":"vector/overview/#contract","title":"Contract","text":"<p>Any backend implementing <code>VectorStorePort</code> can be plugged into <code>VectorRepository</code>. Any backend implementing <code>VectorStorePort</code> or <code>AsyncVectorStorePort</code> can be used with <code>AsyncVectorRepository</code>.</p> <p>Note for async-native stores: - constructor cannot <code>await</code>, so use <code>auto_create=False</code> and call   <code>await repo.create_collection()</code> explicitly.</p>"},{"location":"vector/pgvector/","title":"PgVector Adapter","text":"<p><code>PgVectorStore</code> is an adapter for PostgreSQL with the pgvector extension.</p>"},{"location":"vector/pgvector/#requirements","title":"Requirements","text":"<ul> <li>PostgreSQL with <code>vector</code> extension available.</li> <li>A DB-API PostgreSQL driver (for example <code>psycopg</code> / <code>psycopg2</code>).</li> </ul>"},{"location":"vector/pgvector/#usage","title":"Usage","text":"<pre><code>import psycopg\n\nfrom mini_orm import Database, PgVectorStore, PostgresDialect, VectorRecord, VectorRepository\n\nconn = psycopg.connect(\"host=localhost port=5432 dbname=postgres user=postgres password=password\")\ndb = Database(conn, PostgresDialect())\n\nstore = PgVectorStore(db)\nrepo = VectorRepository(store, \"vector_items\", dimension=4, metric=\"cosine\")\n\nrepo.upsert(\n    [\n        VectorRecord(id=\"1\", vector=[0.1, 0.2, 0.3, 0.4], payload={\"type\": \"doc\"}),\n    ]\n)\n\ntop = repo.query([0.1, 0.2, 0.25, 0.4], top_k=5)\nprint(top)\n</code></pre>"},{"location":"vector/pgvector/#notes","title":"Notes","text":"<ul> <li>Supported metrics: <code>cosine</code>, <code>dot</code>, <code>l2</code>.</li> <li><code>filters</code> are translated into JSONB exact-match checks.</li> <li>Vector and SQL repositories can share the same <code>Database</code>/transaction source.</li> <li>Collection name format supports <code>table</code> or <code>schema.table</code>.</li> </ul>"},{"location":"vector/qdrant/","title":"Qdrant Adapter","text":"<p><code>QdrantVectorStore</code> is an optional adapter for Qdrant.</p>"},{"location":"vector/qdrant/#install","title":"Install","text":"<pre><code>pip install qdrant-client\n</code></pre>"},{"location":"vector/qdrant/#usage","title":"Usage","text":"<pre><code>from mini_orm import QdrantVectorStore, VectorRecord, VectorRepository\n\nstore = QdrantVectorStore(location=\":memory:\")\nrepo = VectorRepository(store, \"items\", dimension=4, metric=\"cosine\")\n\nrepo.upsert(\n    [\n        VectorRecord(\n            id=\"11111111-1111-1111-1111-111111111111\",\n            vector=[0.1, 0.2, 0.3, 0.4],\n            payload={\"type\": \"doc\"},\n        ),\n    ]\n)\n\ntop = repo.query([0.1, 0.2, 0.25, 0.4], top_k=5)\n</code></pre>"},{"location":"vector/qdrant/#notes","title":"Notes","text":"<ul> <li>Qdrant requires UUID string IDs.</li> <li><code>filters</code> are translated into exact-match payload conditions.</li> <li>For persistent local storage, use <code>QdrantVectorStore(location=\\\"./.qdrant\\\")</code>.</li> </ul>"}]}